"""
Unified Technical Calculator
Áµ±Âêà„ÉÜ„ÇØ„Éã„Ç´„É´ÊåáÊ®ôË®àÁÆó„Ç∑„Çπ„ÉÜ„É†

Ë≤¨‰ªª:
- TA-Lib„É©„Ç§„Éñ„É©„É™„Çí‰ΩøÁî®„Åó„ÅüÈ´òÊÄßËÉΩ„ÉÜ„ÇØ„Éã„Ç´„É´ÊåáÊ®ôË®àÁÆó
- Êó¢Â≠ò„Ç∑„Çπ„ÉÜ„É†„ÅÆÁµ±ÂêàÔºàTechnicalIndicatorService, TALibTechnicalIndicatorService, MultiTimeframeTechnicalIndicatorServiceÔºâ
- Â∑ÆÂàÜÊõ¥Êñ∞„Ç∑„Çπ„ÉÜ„É†„Å®„ÅÆÈÄ£Êê∫
- „Éû„É´„ÉÅ„Çø„Ç§„É†„Éï„É¨„Éº„É†ÂØæÂøú

Ë®≠Ë®àÊõ∏ÂèÇÁÖß:
- CLI„Éá„Éº„Çø„Éô„Éº„ÇπÂàùÊúüÂåñ„Ç∑„Çπ„ÉÜ„É†ÂÆüË£Ö‰ªïÊßòÊõ∏_2025.md
- CLI„Éá„Éº„Çø„Éô„Éº„ÇπÂàùÊúüÂåñ„Ç∑„Çπ„ÉÜ„É†ÂÆüË£ÖË®àÁîªÊõ∏_Phase3_ÂàÜÊûêÂá¶ÁêÜ_2025.md
"""

import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple

import numpy as np
import pandas as pd
import talib
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from src.infrastructure.database.connection import get_async_session
from src.infrastructure.database.models.price_data_model import PriceDataModel
from src.infrastructure.database.models.technical_indicator_model import (
    TechnicalIndicatorModel,
)
from src.infrastructure.database.repositories.technical_indicator_repository_impl import (
    TechnicalIndicatorRepositoryImpl,
)


class UnifiedTechnicalCalculator:
    """
    Áµ±Âêà„ÉÜ„ÇØ„Éã„Ç´„É´ÊåáÊ®ôË®àÁÆó„ÇØ„É©„Çπ

    TA-Lib„É©„Ç§„Éñ„É©„É™„Çí‰ΩøÁî®„Åó„Å¶È´òÊÄßËÉΩ„Å™„ÉÜ„ÇØ„Éã„Ç´„É´ÊåáÊ®ôË®àÁÆó„ÇíË°å„ÅÜÊ©üËÉΩ„ÇíÊèê‰æõ
    """

    def __init__(self, currency_pair: str = "USD/JPY"):
        self.currency_pair: str = currency_pair
        self.session: Optional[AsyncSession] = None
        self.indicator_repo: Optional[TechnicalIndicatorRepositoryImpl] = None

        # TA-LibË®≠ÂÆö
        self.indicators_config = {
            "RSI": {"period": 14, "overbought": 70, "oversold": 30},
            "MACD": {"fast_period": 12, "slow_period": 26, "signal_period": 9},
            "BB": {"period": 20, "std_dev": 2},
            "SMA": {"periods": [5, 10, 20, 50, 100, 200]},
            "EMA": {"periods": [12, 26]},
            "STOCH": {"fastk_period": 14, "slowk_period": 3, "slowd_period": 3},
            "ATR": {"period": 14},
        }

        # ÊôÇÈñìË∂≥Ë®≠ÂÆö
        self.timeframes = {
            "M5": {"description": "5ÂàÜË∂≥", "days": 7},
            "H1": {"description": "1ÊôÇÈñìË∂≥", "days": 30},
            "H4": {"description": "4ÊôÇÈñìË∂≥", "days": 60},
            "D1": {"description": "Êó•Ë∂≥", "days": 365},
        }

    async def calculate_all_indicators(self) -> Dict[str, int]:
        """
        ÂÖ®„ÉÜ„ÇØ„Éã„Ç´„É´ÊåáÊ®ô„ÇíË®àÁÆó

        Returns:
            Dict[str, int]: ÂêÑÊôÇÈñìË∂≥„ÅÆË®àÁÆó‰ª∂Êï∞
        """
        results = {}

        for timeframe in ["M5", "H1", "H4", "D1"]:
            print(f"üìä {timeframe}ÊôÇÈñìË∂≥„ÅÆ„ÉÜ„ÇØ„Éã„Ç´„É´ÊåáÊ®ôË®àÁÆó„ÇíÈñãÂßã...")
            count = await self.calculate_timeframe_indicators(timeframe)
            results[timeframe] = count
            print(f"‚úÖ {timeframe}ÊôÇÈñìË∂≥ÊåáÊ®ôË®àÁÆóÂÆå‰∫Ü: {count}‰ª∂")

        return results

    async def calculate_timeframe_indicators(self, timeframe: str) -> int:
        """
        ÁâπÂÆöÊôÇÈñìË∂≥„ÅÆÊåáÊ®ô„ÇíË®àÁÆó

        Args:
            timeframe: ÊôÇÈñìË∂≥

        Returns:
            int: Ë®àÁÆó‰ª∂Êï∞
        """
        try:
            # ‰æ°Ê†º„Éá„Éº„Çø„ÇíÂèñÂæó
            df = await self._get_price_data(timeframe)

            if df.empty:
                print(f"‚ö†Ô∏è {timeframe}„ÅÆ‰æ°Ê†º„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì")
                return 0

            print(f"üìà {timeframe}„Éá„Éº„ÇøÂèñÂæó: {len(df)}‰ª∂")

            # ÂêÑÊåáÊ®ô„ÇíË®àÁÆó
            total_indicators = 0

            # RSIË®àÁÆó
            rsi_count = await self._calculate_and_save_rsi(df, timeframe)
            total_indicators += rsi_count

            # MACDË®àÁÆóÔºàÂçÅÂàÜ„Å™„Éá„Éº„Çø„Åå„ÅÇ„ÇãÂ†¥ÂêàÔºâ
            if len(df) >= 40:
                macd_count = await self._calculate_and_save_macd(df, timeframe)
                total_indicators += macd_count

            # „Éú„É™„É≥„Ç∏„É£„Éº„Éê„É≥„ÉâË®àÁÆó
            bb_count = await self._calculate_and_save_bollinger_bands(df, timeframe)
            total_indicators += bb_count

            # ÁßªÂãïÂπ≥ÂùáÁ∑öË®àÁÆó
            ma_count = await self._calculate_and_save_moving_averages(df, timeframe)
            total_indicators += ma_count

            # „Çπ„Éà„Ç≠„É£„Çπ„ÉÜ„Ç£„ÇØ„ÇπË®àÁÆó
            stoch_count = await self._calculate_and_save_stochastic(df, timeframe)
            total_indicators += stoch_count

            # ATRË®àÁÆó
            atr_count = await self._calculate_and_save_atr(df, timeframe)
            total_indicators += atr_count

            return total_indicators

        except Exception as e:
            print(f"‚ùå {timeframe}ÊåáÊ®ôË®àÁÆó„Ç®„É©„Éº: {e}")
            return 0

    async def _get_price_data(self, timeframe: str) -> pd.DataFrame:
        """
        ‰æ°Ê†º„Éá„Éº„Çø„ÇíÂèñÂæó„Åó„Å¶DataFrame„Å´Â§âÊèõ

        Args:
            timeframe: ÊôÇÈñìË∂≥

        Returns:
            pd.DataFrame: ‰æ°Ê†º„Éá„Éº„Çø
        """
        try:
            # ÊúüÈñìË®≠ÂÆö
            config = self.timeframes[timeframe]
            end_date = datetime.now()
            start_date = end_date - timedelta(days=config["days"])

            # „Éá„Éº„Çø„Éô„Éº„Çπ„Åã„Çâ‰æ°Ê†º„Éá„Éº„Çø„ÇíÂèñÂæó
            query = (
                select(PriceDataModel)
                .where(
                    PriceDataModel.currency_pair == self.currency_pair,
                    PriceDataModel.timestamp >= start_date,
                    PriceDataModel.timestamp <= end_date,
                )
                .order_by(PriceDataModel.timestamp.asc())
            )

            result = await self.session.execute(query)
            price_data = result.scalars().all()

            if not price_data:
                return pd.DataFrame()

            # DataFrame„Å´Â§âÊèõ
            data = []
            for item in price_data:
                data.append(
                    {
                        "timestamp": item.timestamp,
                        "Open": float(item.open_price),
                        "High": float(item.high_price),
                        "Low": float(item.low_price),
                        "Close": float(item.close_price),
                        "Volume": int(item.volume) if item.volume else 1000000,
                    }
                )

            df = pd.DataFrame(data)
            df.set_index("timestamp", inplace=True)

            return df

        except Exception as e:
            print(f"‚ùå ‰æ°Ê†º„Éá„Éº„ÇøÂèñÂæó„Ç®„É©„Éº: {e}")
            return pd.DataFrame()

    async def _calculate_and_save_rsi(self, df: pd.DataFrame, timeframe: str) -> int:
        """
        RSI„ÇíË®àÁÆó„Åó„Å¶‰øùÂ≠ò

        Args:
            df: ‰æ°Ê†º„Éá„Éº„Çø
            timeframe: ÊôÇÈñìË∂≥

        Returns:
            int: ‰øùÂ≠ò‰ª∂Êï∞
        """
        try:
            config = self.indicators_config["RSI"]

            # TA-Lib„ÅßRSIË®àÁÆó
            rsi_values = talib.RSI(df["Close"].values, timeperiod=config["period"])

            # ÊúâÂäπ„Å™ÂÄ§„ÅÆ„Åø„Çí‰øùÂ≠ò
            saved_count = 0
            for i, (timestamp, rsi_value) in enumerate(zip(df.index, rsi_values)):
                if not np.isnan(rsi_value):
                    indicator = TechnicalIndicatorModel(
                        currency_pair=self.currency_pair,
                        timestamp=timestamp,
                        indicator_type="RSI",
                        timeframe=timeframe,
                        value=float(rsi_value),
                        parameters={
                            "period": config["period"],
                            "source": "unified_technical_calculator",
                        },
                    )

                    await self.indicator_repo.save(indicator)
                    saved_count += 1

            print(f"  üìä RSIË®àÁÆóÂÆå‰∫Ü: {saved_count}‰ª∂")
            return saved_count

        except Exception as e:
            print(f"‚ùå RSIË®àÁÆó„Ç®„É©„Éº: {e}")
            return 0

    async def _calculate_and_save_macd(self, df: pd.DataFrame, timeframe: str) -> int:
        """
        MACD„ÇíË®àÁÆó„Åó„Å¶‰øùÂ≠ò

        Args:
            df: ‰æ°Ê†º„Éá„Éº„Çø
            timeframe: ÊôÇÈñìË∂≥

        Returns:
            int: ‰øùÂ≠ò‰ª∂Êï∞
        """
        try:
            config = self.indicators_config["MACD"]

            # TA-Lib„ÅßMACDË®àÁÆó
            macd, macd_signal, macd_hist = talib.MACD(
                df["Close"].values,
                fastperiod=config["fast_period"],
                slowperiod=config["slow_period"],
                signalperiod=config["signal_period"],
            )

            saved_count = 0

            # MACDÁ∑ö
            for i, (timestamp, value) in enumerate(zip(df.index, macd)):
                if not np.isnan(value):
                    indicator = TechnicalIndicatorModel(
                        currency_pair=self.currency_pair,
                        timestamp=timestamp,
                        indicator_type="MACD",
                        timeframe=timeframe,
                        value=float(value),
                        parameters={
                            "fast": config["fast_period"],
                            "slow": config["slow_period"],
                            "signal": config["signal_period"],
                            "source": "unified_technical_calculator",
                        },
                    )
                    await self.indicator_repo.save(indicator)
                    saved_count += 1

            # MACD„Ç∑„Ç∞„Éä„É´Á∑ö
            for i, (timestamp, value) in enumerate(zip(df.index, macd_signal)):
                if not np.isnan(value):
                    indicator = TechnicalIndicatorModel(
                        currency_pair=self.currency_pair,
                        timestamp=timestamp,
                        indicator_type="MACD",
                        timeframe=timeframe,
                        value=float(value),
                        parameters={
                            "fast": config["fast_period"],
                            "slow": config["slow_period"],
                            "signal": config["signal_period"],
                            "source": "unified_technical_calculator",
                        },
                    )
                    await self.indicator_repo.save(indicator)
                    saved_count += 1

            print(f"  üìä MACDË®àÁÆóÂÆå‰∫Ü: {saved_count}‰ª∂")
            return saved_count

        except Exception as e:
            print(f"‚ùå MACDË®àÁÆó„Ç®„É©„Éº: {e}")
            return 0

    async def _calculate_and_save_bollinger_bands(
        self, df: pd.DataFrame, timeframe: str
    ) -> int:
        """
        „Éú„É™„É≥„Ç∏„É£„Éº„Éê„É≥„Éâ„ÇíË®àÁÆó„Åó„Å¶‰øùÂ≠ò

        Args:
            df: ‰æ°Ê†º„Éá„Éº„Çø
            timeframe: ÊôÇÈñìË∂≥

        Returns:
            int: ‰øùÂ≠ò‰ª∂Êï∞
        """
        try:
            config = self.indicators_config["BB"]

            # TA-Lib„Åß„Éú„É™„É≥„Ç∏„É£„Éº„Éê„É≥„ÉâË®àÁÆó
            upper, middle, lower = talib.BBANDS(
                df["Close"].values,
                timeperiod=config["period"],
                nbdevup=config["std_dev"],
                nbdevdn=config["std_dev"],
            )

            saved_count = 0

            # ‰∏ä„Éê„É≥„Éâ
            for i, (timestamp, value) in enumerate(zip(df.index, upper)):
                if not np.isnan(value):
                    indicator = TechnicalIndicatorModel(
                        currency_pair=self.currency_pair,
                        timestamp=timestamp,
                        indicator_type="BB",
                        timeframe=timeframe,
                        value=float(value),
                        parameters={
                            "period": config["period"],
                            "std": config["std_dev"],
                            "source": "unified_technical_calculator",
                        },
                    )
                    await self.indicator_repo.save(indicator)
                    saved_count += 1

            # ‰∏≠„Éê„É≥„ÉâÔºàÁßªÂãïÂπ≥ÂùáÔºâ
            for i, (timestamp, value) in enumerate(zip(df.index, middle)):
                if not np.isnan(value):
                    indicator = TechnicalIndicatorModel(
                        currency_pair=self.currency_pair,
                        timestamp=timestamp,
                        indicator_type="BB",
                        timeframe=timeframe,
                        value=float(value),
                        parameters={
                            "period": config["period"],
                            "std": config["std_dev"],
                            "source": "unified_technical_calculator",
                        },
                    )
                    await self.indicator_repo.save(indicator)
                    saved_count += 1

            # ‰∏ã„Éê„É≥„Éâ
            for i, (timestamp, value) in enumerate(zip(df.index, lower)):
                if not np.isnan(value):
                    indicator = TechnicalIndicatorModel(
                        currency_pair=self.currency_pair,
                        timestamp=timestamp,
                        indicator_type="BB",
                        timeframe=timeframe,
                        value=float(value),
                        parameters={
                            "period": config["period"],
                            "std": config["std_dev"],
                            "source": "unified_technical_calculator",
                        },
                    )
                    await self.indicator_repo.save(indicator)
                    saved_count += 1

            print(f"  üìä „Éú„É™„É≥„Ç∏„É£„Éº„Éê„É≥„ÉâË®àÁÆóÂÆå‰∫Ü: {saved_count}‰ª∂")
            return saved_count

        except Exception as e:
            print(f"‚ùå „Éú„É™„É≥„Ç∏„É£„Éº„Éê„É≥„ÉâË®àÁÆó„Ç®„É©„Éº: {e}")
            return 0

    async def _calculate_and_save_moving_averages(
        self, df: pd.DataFrame, timeframe: str
    ) -> int:
        """
        ÁßªÂãïÂπ≥ÂùáÁ∑ö„ÇíË®àÁÆó„Åó„Å¶‰øùÂ≠ò

        Args:
            df: ‰æ°Ê†º„Éá„Éº„Çø
            timeframe: ÊôÇÈñìË∂≥

        Returns:
            int: ‰øùÂ≠ò‰ª∂Êï∞
        """
        try:
            sma_config = self.indicators_config["SMA"]
            ema_config = self.indicators_config["EMA"]

            saved_count = 0

            # SMAË®àÁÆó
            for period in sma_config["periods"]:
                sma_values = talib.SMA(df["Close"].values, timeperiod=period)

                for i, (timestamp, value) in enumerate(zip(df.index, sma_values)):
                    if not np.isnan(value):
                        indicator = TechnicalIndicatorModel(
                            currency_pair=self.currency_pair,
                            timestamp=timestamp,
                            indicator_type="SMA",
                            timeframe=timeframe,
                            value=float(value),
                            parameters={
                                "period": period,
                                "source": "unified_technical_calculator",
                            },
                        )
                        await self.indicator_repo.save(indicator)
                        saved_count += 1

            # EMAË®àÁÆó
            for period in ema_config["periods"]:
                ema_values = talib.EMA(df["Close"].values, timeperiod=period)

                for i, (timestamp, value) in enumerate(zip(df.index, ema_values)):
                    if not np.isnan(value):
                        indicator = TechnicalIndicatorModel(
                            currency_pair=self.currency_pair,
                            timestamp=timestamp,
                            indicator_type="EMA",
                            timeframe=timeframe,
                            value=float(value),
                            parameters={
                                "period": period,
                                "source": "unified_technical_calculator",
                            },
                        )
                        await self.indicator_repo.save(indicator)
                        saved_count += 1

            print(f"  üìä ÁßªÂãïÂπ≥ÂùáÁ∑öË®àÁÆóÂÆå‰∫Ü: {saved_count}‰ª∂")
            return saved_count

        except Exception as e:
            print(f"‚ùå ÁßªÂãïÂπ≥ÂùáÁ∑öË®àÁÆó„Ç®„É©„Éº: {e}")
            return 0

    async def _calculate_and_save_stochastic(
        self, df: pd.DataFrame, timeframe: str
    ) -> int:
        """
        „Çπ„Éà„Ç≠„É£„Çπ„ÉÜ„Ç£„ÇØ„Çπ„ÇíË®àÁÆó„Åó„Å¶‰øùÂ≠ò

        Args:
            df: ‰æ°Ê†º„Éá„Éº„Çø
            timeframe: ÊôÇÈñìË∂≥

        Returns:
            int: ‰øùÂ≠ò‰ª∂Êï∞
        """
        try:
            config = self.indicators_config["STOCH"]

            # TA-Lib„Åß„Çπ„Éà„Ç≠„É£„Çπ„ÉÜ„Ç£„ÇØ„ÇπË®àÁÆó
            slowk, slowd = talib.STOCH(
                df["High"].values,
                df["Low"].values,
                df["Close"].values,
                fastk_period=config["fastk_period"],
                slowk_period=config["slowk_period"],
                slowd_period=config["slowd_period"],
            )

            saved_count = 0

            # %KÁ∑ö
            for i, (timestamp, value) in enumerate(zip(df.index, slowk)):
                if not np.isnan(value):
                    indicator = TechnicalIndicatorModel(
                        currency_pair=self.currency_pair,
                        timestamp=timestamp,
                        indicator_type="STOCH",
                        timeframe=timeframe,
                        value=float(value),
                        parameters={
                            "fastk": config["fastk_period"],
                            "slowk": config["slowk_period"],
                            "slowd": config["slowd_period"],
                            "source": "unified_technical_calculator",
                        },
                    )
                    await self.indicator_repo.save(indicator)
                    saved_count += 1

            # %DÁ∑ö
            for i, (timestamp, value) in enumerate(zip(df.index, slowd)):
                if not np.isnan(value):
                    indicator = TechnicalIndicatorModel(
                        currency_pair=self.currency_pair,
                        timestamp=timestamp,
                        indicator_type="STOCH",
                        timeframe=timeframe,
                        value=float(value),
                        parameters={
                            "fastk": config["fastk_period"],
                            "slowk": config["slowk_period"],
                            "slowd": config["slowd_period"],
                            "source": "unified_technical_calculator",
                        },
                    )
                    await self.indicator_repo.save(indicator)
                    saved_count += 1

            print(f"  üìä „Çπ„Éà„Ç≠„É£„Çπ„ÉÜ„Ç£„ÇØ„ÇπË®àÁÆóÂÆå‰∫Ü: {saved_count}‰ª∂")
            return saved_count

        except Exception as e:
            print(f"‚ùå „Çπ„Éà„Ç≠„É£„Çπ„ÉÜ„Ç£„ÇØ„ÇπË®àÁÆó„Ç®„É©„Éº: {e}")
            return 0

    async def _calculate_and_save_atr(self, df: pd.DataFrame, timeframe: str) -> int:
        """
        ATR„ÇíË®àÁÆó„Åó„Å¶‰øùÂ≠ò

        Args:
            df: ‰æ°Ê†º„Éá„Éº„Çø
            timeframe: ÊôÇÈñìË∂≥

        Returns:
            int: ‰øùÂ≠ò‰ª∂Êï∞
        """
        try:
            config = self.indicators_config["ATR"]

            # TA-Lib„ÅßATRË®àÁÆó
            atr_values = talib.ATR(
                df["High"].values,
                df["Low"].values,
                df["Close"].values,
                timeperiod=config["period"],
            )

            saved_count = 0

            for i, (timestamp, value) in enumerate(zip(df.index, atr_values)):
                if not np.isnan(value):
                    indicator = TechnicalIndicatorModel(
                        currency_pair=self.currency_pair,
                        timestamp=timestamp,
                        indicator_type="ATR",
                        timeframe=timeframe,
                        value=float(value),
                        parameters={
                            "period": config["period"],
                            "source": "unified_technical_calculator",
                        },
                    )
                    await self.indicator_repo.save(indicator)
                    saved_count += 1

            print(f"  üìä ATRË®àÁÆóÂÆå‰∫Ü: {saved_count}‰ª∂")
            return saved_count

        except Exception as e:
            print(f"‚ùå ATRË®àÁÆó„Ç®„É©„Éº: {e}")
            return 0

    async def initialize(self) -> bool:
        """
        ÂàùÊúüÂåñÂá¶ÁêÜ

        Returns:
            bool: ÂàùÊúüÂåñÊàêÂäüÊôÇTrue„ÄÅÂ§±ÊïóÊôÇFalse
        """
        try:
            # „Çª„ÉÉ„Ç∑„Éß„É≥„ÅÆÂàùÊúüÂåñ
            self.session = await get_async_session()

            # „É™„Éù„Ç∏„Éà„É™„ÅÆÂàùÊúüÂåñ
            self.indicator_repo = TechnicalIndicatorRepositoryImpl(self.session)

            return True

        except Exception as e:
            print(f"‚ùå ÂàùÊúüÂåñ„Ç®„É©„Éº: {e}")
            return False

    async def cleanup(self) -> None:
        """
        „É™„ÇΩ„Éº„Çπ„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
        """
        if self.session:
            await self.session.close()


async def main():
    """
    „É°„Ç§„É≥ÂÆüË°åÈñ¢Êï∞
    """
    calculator = UnifiedTechnicalCalculator()

    try:
        # ÂàùÊúüÂåñ
        if not await calculator.initialize():
            print("‚ùå ÂàùÊúüÂåñ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü")
            return 1

        # „ÉÜ„ÇØ„Éã„Ç´„É´ÊåáÊ®ôË®àÁÆóÂÆüË°å
        results = await calculator.calculate_all_indicators()

        # ÁµêÊûúË°®Á§∫
        total_count = sum(results.values())
        print("\nüìä Áµ±Âêà„ÉÜ„ÇØ„Éã„Ç´„É´ÊåáÊ®ôË®àÁÆóÁµêÊûú:")
        for timeframe, count in results.items():
            print(f"   {timeframe}: {count}‰ª∂")
        print(f"   ÂêàË®à: {total_count}‰ª∂")

        if total_count > 0:
            print("üéâ Áµ±Âêà„ÉÜ„ÇØ„Éã„Ç´„É´ÊåáÊ®ôË®àÁÆó„ÅåÊ≠£Â∏∏„Å´ÂÆå‰∫Ü„Åó„Åæ„Åó„Åü")
        else:
            print("‚ÑπÔ∏è Ë®àÁÆóÂØæË±°„ÅÆ„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü")

    except Exception as e:
        print(f"‚ùå ‰∫àÊúü„Åó„Å™„ÅÑ„Ç®„É©„Éº: {e}")
        return 1
    finally:
        await calculator.cleanup()

    return 0


if __name__ == "__main__":
    exit_code = asyncio.run(main())
    exit(exit_code)
