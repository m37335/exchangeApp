"""
TA-Lib Technical Indicator Service
TA-Libを使用したテクニカル指標計算・保存サービス

機能:
- TA-Libを使用した高精度指標計算
- データベース保存
- 複数時間軸対応
- 移動平均線を含む全指標対応
"""

import json
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

import pandas as pd
from sqlalchemy.ext.asyncio import AsyncSession

from src.infrastructure.analysis.talib_technical_indicators import (
    TALibTechnicalIndicators,
)
from src.infrastructure.database.models.price_data_model import PriceDataModel
from src.infrastructure.database.models.technical_indicator_model import (
    TechnicalIndicatorModel,
)
from src.infrastructure.database.repositories.price_data_repository_impl import (
    PriceDataRepositoryImpl,
)
from src.infrastructure.database.repositories.technical_indicator_repository_impl import (
    TechnicalIndicatorRepositoryImpl,
)
from src.utils.logging_config import get_infrastructure_logger

logger = get_infrastructure_logger()


class TALibTechnicalIndicatorService:
    """
    TA-Libテクニカル指標サービス

    責任:
    - TA-Libを使用したテクニカル指標計算
    - 計算結果のデータベース保存
    - 複数タイムフレーム対応
    - 移動平均線を含む全指標対応

    特徴:
    - TA-Libによる高精度計算
    - 包括的な指標セット
    - 効率的なデータベース保存
    - 重複防止機能
    """

    def __init__(self, session: AsyncSession):
        """
        初期化

        Args:
            session: データベースセッション
        """
        self.session = session

        # リポジトリ初期化
        self.indicator_repo = TechnicalIndicatorRepositoryImpl(session)
        self.price_repo = PriceDataRepositoryImpl(session)

        # TA-Lib計算エンジン初期化
        self.talib_calculator = TALibTechnicalIndicators()

        # USD/JPY設定
        self.currency_pair = "USD/JPY"

        # 対応時間軸
        self.timeframes = {
            "M5": {"days": 7, "description": "5分足"},
            "H1": {"days": 30, "description": "1時間足"},
            "H4": {"days": 60, "description": "4時間足"},
            "D1": {"days": 365, "description": "日足"},
        }

        # 移動平均線の複数期間設定
        self.ma_periods = {
            "short": 20,
            "medium": 50,
            "long": 200,
        }

        logger.info("Initialized TALib Technical Indicator Service")

    async def calculate_and_save_all_indicators(
        self, timeframe: str = "M5"
    ) -> Dict[str, int]:
        """
        全テクニカル指標を計算して保存

        Args:
            timeframe: 時間軸

        Returns:
            Dict[str, int]: 各指標の保存件数
        """
        try:
            if timeframe not in self.timeframes:
                logger.error(f"Invalid timeframe: {timeframe}")
                return {}

            config = self.timeframes[timeframe]
            logger.info(f"Calculating {config['description']} indicators...")

            # 価格データを取得
            end_date = datetime.now()
            start_date = end_date - timedelta(days=config["days"])

            price_data = await self.price_repo.find_by_date_range(
                start_date, end_date, self.currency_pair, 10000
            )

            if len(price_data) < 20:
                logger.warning(f"Insufficient data: {len(price_data)} < 20")
                return {}

            # DataFrameに変換
            df = self._convert_to_dataframe(price_data)
            if df.empty:
                logger.warning("Empty DataFrame")
                return {}

            logger.info(f"Data prepared: {len(df)} records")

            # 各指標を計算して保存
            results = {}

            # RSI計算・保存
            rsi_count = await self._calculate_and_save_rsi(df, timeframe)
            results["RSI"] = rsi_count

            # MACD計算・保存（十分なデータがある場合）
            if len(df) >= 40:
                macd_count = await self._calculate_and_save_macd(df, timeframe)
                results["MACD"] = macd_count

            # ボリンジャーバンド計算・保存
            bb_count = await self._calculate_and_save_bollinger_bands(df, timeframe)
            results["BB"] = bb_count

            # 移動平均線計算・保存
            sma_count = await self._calculate_and_save_moving_averages(
                df, timeframe, "SMA"
            )
            results["SMA"] = sma_count

            ema_count = await self._calculate_and_save_moving_averages(
                df, timeframe, "EMA"
            )
            results["EMA"] = ema_count

            # ストキャスティクス計算・保存
            stoch_count = await self._calculate_and_save_stochastic(df, timeframe)
            results["STOCH"] = stoch_count

            # ATR計算・保存
            atr_count = await self._calculate_and_save_atr(df, timeframe)
            results["ATR"] = atr_count

            total_count = sum(results.values())
            logger.info(f"Completed {timeframe} indicators: {total_count} total")
            return results

        except Exception as e:
            logger.error(f"Error calculating indicators for {timeframe}: {e}")
            return {}

    async def _calculate_and_save_rsi(self, df: pd.DataFrame, timeframe: str) -> int:
        """RSIを計算して保存"""
        try:
            # RSI計算
            rsi_result = self.talib_calculator.calculate_rsi(df, timeframe=timeframe)

            if "error" in rsi_result:
                logger.warning(f"RSI calculation error: {rsi_result['error']}")
                return 0

            # 保存
            saved_count = await self._save_indicator("RSI", timeframe, rsi_result)

            logger.info(f"Saved {saved_count} RSI indicators for {timeframe}")
            return saved_count

        except Exception as e:
            logger.error(f"Error in RSI calculation: {e}")
            return 0

    async def _calculate_and_save_macd(self, df: pd.DataFrame, timeframe: str) -> int:
        """MACDを計算して保存"""
        try:
            # MACD計算
            macd_result = self.talib_calculator.calculate_macd(df, timeframe=timeframe)

            if "error" in macd_result:
                logger.warning(f"MACD calculation error: {macd_result['error']}")
                return 0

            # 保存
            saved_count = await self._save_indicator("MACD", timeframe, macd_result)

            logger.info(f"Saved {saved_count} MACD indicators for {timeframe}")
            return saved_count

        except Exception as e:
            logger.error(f"Error in MACD calculation: {e}")
            return 0

    async def _calculate_and_save_bollinger_bands(
        self, df: pd.DataFrame, timeframe: str
    ) -> int:
        """ボリンジャーバンドを計算して保存"""
        try:
            # ボリンジャーバンド計算
            bb_result = self.talib_calculator.calculate_bollinger_bands(
                df, timeframe=timeframe
            )

            if "error" in bb_result:
                logger.warning(f"BB calculation error: {bb_result['error']}")
                return 0

            # 保存
            saved_count = await self._save_indicator("BB", timeframe, bb_result)

            logger.info(f"Saved {saved_count} BB indicators for {timeframe}")
            return saved_count

        except Exception as e:
            logger.error(f"Error in BB calculation: {e}")
            return 0

    async def _calculate_and_save_moving_averages(
        self, df: pd.DataFrame, timeframe: str, ma_type: str
    ) -> int:
        """移動平均線を計算して保存"""
        try:
            total_saved = 0

            # 複数期間の移動平均線を計算
            for period_name, period in self.ma_periods.items():
                if ma_type == "SMA":
                    ma_result = self.talib_calculator.calculate_sma(
                        df, period=period, timeframe=timeframe
                    )
                else:  # EMA
                    ma_result = self.talib_calculator.calculate_ema(
                        df, period=period, timeframe=timeframe
                    )

                if "error" in ma_result:
                    logger.warning(f"{ma_type} calculation error: {ma_result['error']}")
                    continue

                # 保存（指標タイプを短縮）
                indicator_type = (
                    f"{ma_type}{period_name[0].upper()}"  # SMA_S -> SMAS, EMA_M -> EMAM
                )
                saved_count = await self._save_indicator(
                    indicator_type, timeframe, ma_result
                )
                total_saved += saved_count

            logger.info(f"Saved {total_saved} {ma_type} indicators for {timeframe}")
            return total_saved

        except Exception as e:
            logger.error(f"Error in {ma_type} calculation: {e}")
            return 0

    async def _calculate_and_save_stochastic(
        self, df: pd.DataFrame, timeframe: str
    ) -> int:
        """ストキャスティクスを計算して保存"""
        try:
            # ストキャスティクス計算
            stoch_result = self.talib_calculator.calculate_stochastic(
                df, timeframe=timeframe
            )

            if "error" in stoch_result:
                logger.warning(f"Stochastic calculation error: {stoch_result['error']}")
                return 0

            # 保存
            saved_count = await self._save_indicator("STOCH", timeframe, stoch_result)

            logger.info(f"Saved {saved_count} Stochastic indicators for {timeframe}")
            return saved_count

        except Exception as e:
            logger.error(f"Error in Stochastic calculation: {e}")
            return 0

    async def _calculate_and_save_atr(self, df: pd.DataFrame, timeframe: str) -> int:
        """ATRを計算して保存"""
        try:
            # ATR計算
            atr_result = self.talib_calculator.calculate_atr(df, timeframe=timeframe)

            if "error" in atr_result:
                logger.warning(f"ATR calculation error: {atr_result['error']}")
                return 0

            # 保存
            saved_count = await self._save_indicator("ATR", timeframe, atr_result)

            logger.info(f"Saved {saved_count} ATR indicators for {timeframe}")
            return saved_count

        except Exception as e:
            logger.error(f"Error in ATR calculation: {e}")
            return 0

    async def _save_indicator(
        self, indicator_type: str, timeframe: str, result: Dict
    ) -> int:
        """指標をデータベースに保存"""
        try:
            # 最新の価格データのタイムスタンプを取得
            latest_prices = await self.price_repo.find_latest(self.currency_pair)

            if not latest_prices:
                logger.warning("No latest price data found")
                return 0

            latest_price = latest_prices[0]  # 最初の要素を取得

            # テクニカル指標モデルを作成
            indicator = TechnicalIndicatorModel(
                currency_pair=self.currency_pair,
                timestamp=latest_price.timestamp,
                indicator_type=indicator_type,
                timeframe=timeframe,
                value=result["current_value"],
                additional_data=json.dumps(result.get("additional_data", {})),
                parameters=json.dumps(
                    {
                        "period": result.get("period"),
                        "state": result.get("state"),
                        "calculation_time": (
                            result.get("calculation_time").isoformat()
                            if result.get("calculation_time")
                            else None
                        ),
                    }
                ),
            )

            # 重複チェック（一時的に無効化）
            # existing = await self.indicator_repo.find_recent_by_type(
            #     indicator_type, timeframe, self.currency_pair, hours=1
            # )
            #
            # if existing:
            #     logger.info(
            #         f"Indicator {indicator_type} for {timeframe} already exists"
            #     )
            #     return 0

            # 保存
            saved_indicator = await self.indicator_repo.save(indicator)
            logger.info(f"Saved {indicator_type} indicator: {saved_indicator.value}")
            return 1

        except Exception as e:
            logger.error(f"Error saving indicator {indicator_type}: {e}")
            return 0

    def _convert_to_dataframe(self, price_data: List[PriceDataModel]) -> pd.DataFrame:
        """価格データをDataFrameに変換"""
        try:
            if not price_data:
                return pd.DataFrame()

            data = []
            for item in price_data:
                data.append(
                    {
                        "Open": item.open_price,
                        "High": item.high_price,
                        "Low": item.low_price,
                        "Close": item.close_price,
                        "Volume": item.volume,
                        "timestamp": item.timestamp,
                    }
                )

            df = pd.DataFrame(data)
            df = df.sort_values("timestamp").reset_index(drop=True)

            return df

        except Exception as e:
            logger.error(f"Error converting to DataFrame: {e}")
            return pd.DataFrame()

    async def get_latest_indicators_by_timeframe(
        self, timeframe: str, limit: int = 10
    ) -> Dict[str, Any]:
        """
        指定時間軸の最新指標を取得

        Args:
            timeframe: 時間軸
            limit: 取得件数

        Returns:
            Dict: 最新指標データ
        """
        try:
            indicators = await self.indicator_repo.find_latest_by_timeframe(
                timeframe, self.currency_pair, limit
            )

            result = {}
            for indicator in indicators:
                if indicator.indicator_type not in result:
                    result[indicator.indicator_type] = []

                result[indicator.indicator_type].append(
                    {
                        "value": indicator.value,
                        "timestamp": indicator.timestamp,
                        "additional_data": (
                            json.loads(indicator.additional_data)
                            if indicator.additional_data
                            else {}
                        ),
                        "parameters": (
                            json.loads(indicator.parameters)
                            if indicator.parameters
                            else {}
                        ),
                    }
                )

            return result

        except Exception as e:
            logger.error(f"Error getting latest indicators: {e}")
            return {}

    async def calculate_all_timeframe_indicators(self) -> Dict[str, Dict]:
        """
        全時間軸のテクニカル指標を計算

        Returns:
            Dict: 全時間軸の計算結果
        """
        try:
            results = {}

            for timeframe in self.timeframes.keys():
                timeframe_results = await self.calculate_and_save_all_indicators(
                    timeframe
                )
                results[timeframe] = timeframe_results

            return results

        except Exception as e:
            logger.error(f"Error calculating all timeframe indicators: {e}")
            return {}
