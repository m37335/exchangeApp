# モジュール型システム開発 ベストプラクティスワークフローガイド

**作成日**: 2025 年 9 月 6 日  
**対象システム**: Exchange Analytics System  
**目的**: 基幹モジュールを保護しながら新機能を安全に追加する開発ワークフロー

## 📋 目次

1. [概要](#概要)
2. [現在のシステム構造分析](#現在のシステム構造分析)
3. [基幹モジュール保護戦略](#基幹モジュール保護戦略)
4. [新機能追加ワークフロー](#新機能追加ワークフロー)
5. [ディレクトリ構造設計](#ディレクトリ構造設計)
6. [設定管理のベストプラクティス](#設定管理のベストプラクティス)
7. [テスト戦略](#テスト戦略)
8. [デプロイメント戦略](#デプロイメント戦略)
9. [監視・ログ・メトリクス](#監視ログメトリクス)
10. [実装の優先順位](#実装の優先順位)

## 概要

### 目的

- **基幹モジュールの完全保護**: 既存システムの安定性を維持
- **新機能の安全な追加**: システムを壊すことなく機能拡張
- **モジュール型開発**: 機能の独立性と再利用性を確保
- **段階的開発**: リスクを最小化した開発プロセス

### 基本原則

1. **基幹モジュールは絶対に触らない**
2. **新機能は独立したモジュールとして実装**
3. **インターフェースを通じて基幹モジュールと連携**
4. **段階的なテストとデプロイ**

## 現在のシステム構造分析

### 基幹モジュール（保護対象）

```
/app/src/
├── application/          # ビジネスロジック層
│   ├── commands/        # コマンドパターン
│   ├── queries/         # クエリパターン
│   ├── use_cases/       # ユースケース
│   └── dto/            # データ転送オブジェクト
├── domain/              # ドメインモデル層
├── infrastructure/      # インフラストラクチャ層
│   ├── database/       # データベース関連
│   ├── messaging/      # メッセージング
│   └── monitoring/     # 監視機能
└── presentation/        # プレゼンテーション層
    └── cli/            # CLI インターフェース
```

### 機能別モジュール（拡張対象）

```
/app/scripts/
├── analysis/           # 分析機能
├── cron/              # 定期実行機能
├── monitoring/        # 監視機能
└── deployment/        # デプロイメント機能
```

### 設定・管理モジュール

```
/app/config/
├── base.py            # 基幹設定（保護対象）
├── development.py     # 開発環境設定
├── production.py      # 本番環境設定
└── testing.py         # テスト環境設定
```

## 基幹モジュール保護戦略

### 保護対象ファイル

```yaml
絶対に触ってはいけないファイル:
  - /app/src/application/
  - /app/src/domain/
  - /app/src/infrastructure/core/
  - /app/config/base.py
  - /app/.env
  - /app/requirements.txt
  - /app/pyproject.toml

禁止事項:
  - 基幹モジュールの直接修正
  - 既存APIの破壊的変更
  - データベーススキーマの破壊的変更
  - 環境変数の削除・変更
```

### 保護ルール

1. **読み取り専用**: 基幹モジュールは参照のみ
2. **インターフェース経由**: 直接呼び出し禁止
3. **設定の継承**: 基幹設定を継承して拡張
4. **テストの分離**: 基幹テストと機能テストを分離

## 新機能追加ワークフロー

### Phase 1: 準備段階

```bash
# 1. 新機能ディレクトリの作成
mkdir -p /app/modules/new_feature/{handlers,services,tests,config,interfaces}

# 2. 設定ファイルの分離
cp /app/config/base.py /app/config/features/new_feature.py

# 3. 依存関係の分離
touch /app/requirements/features/new_feature.txt
```

### Phase 2: インターフェース設計

```python
# /app/modules/new_feature/interfaces/base.py
from abc import ABC, abstractmethod
from typing import Any, Dict

class NewFeatureInterface(ABC):
    """新機能の標準インターフェース"""

    @abstractmethod
    async def initialize(self) -> bool:
        """初期化処理"""
        pass

    @abstractmethod
    async def execute(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """実行処理"""
        pass

    @abstractmethod
    async def cleanup(self) -> None:
        """クリーンアップ処理"""
        pass

    @abstractmethod
    def get_status(self) -> Dict[str, Any]:
        """ステータス取得"""
        pass
```

### Phase 3: 実装

```python
# /app/modules/new_feature/services/implementation.py
from ..interfaces.base import NewFeatureInterface
from ...src.infrastructure.database.services.base_repository import BaseRepository

class NewFeatureService(NewFeatureInterface):
    """新機能の実装クラス"""

    def __init__(self, repository: BaseRepository):
        self.repository = repository
        self.is_initialized = False

    async def initialize(self) -> bool:
        """基幹モジュールを使用した初期化"""
        try:
            # 基幹モジュールの機能を使用
            await self.repository.initialize()
            self.is_initialized = True
            return True
        except Exception as e:
            print(f"初期化エラー: {e}")
            return False

    async def execute(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """新機能の実行"""
        if not self.is_initialized:
            return {"status": "error", "message": "未初期化"}

        try:
            # 新機能の実装
            result = await self._process_new_feature(params)
            return {"status": "success", "result": result}
        except Exception as e:
            return {"status": "error", "message": str(e)}

    async def cleanup(self) -> None:
        """クリーンアップ処理"""
        if self.is_initialized:
            await self.repository.cleanup()
            self.is_initialized = False

    def get_status(self) -> Dict[str, Any]:
        """ステータス取得"""
        return {
            "initialized": self.is_initialized,
            "feature_name": "new_feature"
        }

    async def _process_new_feature(self, params: Dict[str, Any]) -> Any:
        """新機能の具体的な処理"""
        # ここに新機能の実装を記述
        return {"processed": True, "params": params}
```

### Phase 4: 統合

```python
# /app/scripts/new_feature/main.py
import sys
import asyncio
from pathlib import Path

# プロジェクトルートをパスに追加
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

from modules.new_feature.services.implementation import NewFeatureService
from src.infrastructure.database.services.base_repository import BaseRepository

async def main():
    """新機能のメイン実行関数"""
    # 基幹モジュールを使用して新機能を初期化
    repository = BaseRepository()
    service = NewFeatureService(repository)

    try:
        # 初期化
        if not await service.initialize():
            print("❌ 初期化に失敗しました")
            return

        # 実行
        result = await service.execute({"param": "test_value"})
        print(f"✅ 実行結果: {result}")

        # ステータス確認
        status = service.get_status()
        print(f"📊 ステータス: {status}")

    except Exception as e:
        print(f"❌ エラー: {e}")
    finally:
        # クリーンアップ
        await service.cleanup()

if __name__ == "__main__":
    asyncio.run(main())
```

## ディレクトリ構造設計

### 推奨ディレクトリ構造

```
/app/
├── src/                    # 基幹モジュール（保護対象）
│   ├── application/
│   ├── domain/
│   ├── infrastructure/
│   └── presentation/
├── modules/                # 新機能モジュール（追加対象）
│   ├── feature_a/
│   │   ├── __init__.py
│   │   ├── interfaces/
│   │   │   ├── __init__.py
│   │   │   └── base.py
│   │   ├── services/
│   │   │   ├── __init__.py
│   │   │   └── implementation.py
│   │   ├── handlers/
│   │   │   ├── __init__.py
│   │   │   └── event_handler.py
│   │   ├── tests/
│   │   │   ├── __init__.py
│   │   │   ├── test_unit.py
│   │   │   └── test_integration.py
│   │   └── config/
│   │       ├── __init__.py
│   │       └── settings.py
│   └── feature_b/
├── scripts/                # 機能別スクリプト（拡張対象）
│   ├── analysis/
│   ├── monitoring/
│   ├── new_feature/
│   └── deployment/
├── config/
│   ├── base.py            # 基幹設定（保護対象）
│   ├── development.py
│   ├── production.py
│   └── features/          # 機能別設定（追加対象）
│       ├── __init__.py
│       ├── feature_a.py
│       └── feature_b.py
├── tests/
│   ├── core/              # 基幹モジュールのテスト
│   │   ├── test_application/
│   │   ├── test_domain/
│   │   └── test_infrastructure/
│   └── features/          # 機能別テスト
│       ├── test_feature_a/
│       └── test_feature_b/
└── requirements/
    ├── base.txt           # 基幹依存関係
    ├── development.txt
    ├── production.txt
    └── features/          # 機能別依存関係
        ├── feature_a.txt
        └── feature_b.txt
```

### ディレクトリ作成コマンド

```bash
# 新機能モジュールの作成
mkdir -p /app/modules/new_feature/{interfaces,services,handlers,tests,config}

# 設定ディレクトリの作成
mkdir -p /app/config/features

# テストディレクトリの作成
mkdir -p /app/tests/{core,features}

# 依存関係ディレクトリの作成
mkdir -p /app/requirements/features
```

## 設定管理のベストプラクティス

### 設定の階層化

```python
# /app/config/features/new_feature.py
from ..base import BaseConfig
import os

class NewFeatureConfig(BaseConfig):
    """新機能の設定クラス"""

    # 新機能固有の設定
    NEW_FEATURE_ENABLED: bool = True
    NEW_FEATURE_TIMEOUT: int = 30
    NEW_FEATURE_RETRY_COUNT: int = 3
    NEW_FEATURE_LOG_LEVEL: str = "INFO"

    def __init__(self):
        super().__init__()
        self._load_feature_config()

    def _load_feature_config(self):
        """環境変数から機能別設定を読み込み"""
        self.NEW_FEATURE_ENABLED = os.getenv(
            "NEW_FEATURE_ENABLED", "true"
        ).lower() == "true"

        self.NEW_FEATURE_TIMEOUT = int(os.getenv(
            "NEW_FEATURE_TIMEOUT", "30"
        ))

        self.NEW_FEATURE_RETRY_COUNT = int(os.getenv(
            "NEW_FEATURE_RETRY_COUNT", "3"
        ))

        self.NEW_FEATURE_LOG_LEVEL = os.getenv(
            "NEW_FEATURE_LOG_LEVEL", "INFO"
        )

    def get_config_dict(self) -> dict:
        """設定を辞書形式で取得"""
        return {
            "enabled": self.NEW_FEATURE_ENABLED,
            "timeout": self.NEW_FEATURE_TIMEOUT,
            "retry_count": self.NEW_FEATURE_RETRY_COUNT,
            "log_level": self.NEW_FEATURE_LOG_LEVEL
        }
```

### 環境変数の分離

```bash
# .env.features (新機能固有の環境変数)
NEW_FEATURE_ENABLED=true
NEW_FEATURE_TIMEOUT=30
NEW_FEATURE_RETRY_COUNT=3
NEW_FEATURE_LOG_LEVEL=INFO

# 基幹設定は .env に残す
DATABASE_URL=postgresql+asyncpg://...
DISCORD_WEBHOOK_URL=https://...
```

### 機能管理クラス

```python
# /app/modules/feature_manager.py
import os
import importlib
from typing import Dict, Any

class FeatureManager:
    """機能管理クラス"""

    def __init__(self):
        self.features = {
            "new_feature": os.getenv("NEW_FEATURE_ENABLED", "false").lower() == "true",
            "another_feature": os.getenv("ANOTHER_FEATURE_ENABLED", "false").lower() == "true"
        }

    def is_enabled(self, feature_name: str) -> bool:
        """機能が有効かチェック"""
        return self.features.get(feature_name, False)

    def get_feature_config(self, feature_name: str) -> Dict[str, Any]:
        """機能設定を取得"""
        if not self.is_enabled(feature_name):
            return {}

        try:
            # 機能別設定を読み込み
            config_module = f"config.features.{feature_name}"
            config_class = importlib.import_module(config_module)
            return config_class.get_config_dict()
        except ImportError:
            return {}

    def list_enabled_features(self) -> list:
        """有効な機能のリストを取得"""
        return [name for name, enabled in self.features.items() if enabled]

    def get_feature_status(self) -> Dict[str, Dict[str, Any]]:
        """全機能のステータスを取得"""
        status = {}
        for feature_name in self.features.keys():
            status[feature_name] = {
                "enabled": self.is_enabled(feature_name),
                "config": self.get_feature_config(feature_name)
            }
        return status
```

## テスト戦略

### テストの分離

```
/app/tests/
├── core/                  # 基幹モジュールのテスト
│   ├── test_application/
│   │   ├── test_commands.py
│   │   ├── test_queries.py
│   │   └── test_use_cases.py
│   ├── test_domain/
│   │   ├── test_models.py
│   │   └── test_services.py
│   └── test_infrastructure/
│       ├── test_database.py
│       ├── test_messaging.py
│       └── test_monitoring.py
└── features/              # 機能別テスト
    ├── test_new_feature/
    │   ├── test_unit.py
    │   ├── test_integration.py
    │   └── test_e2e.py
    └── test_another_feature/
```

### 単体テスト

```python
# /app/tests/features/test_new_feature/test_unit.py
import pytest
from modules.new_feature.services.implementation import NewFeatureService
from src.infrastructure.database.services.base_repository import BaseRepository

class TestNewFeatureUnit:
    """新機能の単体テスト"""

    @pytest.fixture
    def mock_repository(self):
        """モックリポジトリ"""
        return BaseRepository()

    @pytest.fixture
    def service(self, mock_repository):
        """テスト用サービス"""
        return NewFeatureService(mock_repository)

    async def test_initialization(self, service):
        """初期化テスト"""
        result = await service.initialize()
        assert result is True
        assert service.is_initialized is True

    async def test_execution_success(self, service):
        """実行成功テスト"""
        await service.initialize()
        result = await service.execute({"param": "test"})
        assert result["status"] == "success"

    async def test_execution_failure(self, service):
        """実行失敗テスト"""
        result = await service.execute({"param": "test"})
        assert result["status"] == "error"
        assert "未初期化" in result["message"]

    def test_get_status(self, service):
        """ステータス取得テスト"""
        status = service.get_status()
        assert "initialized" in status
        assert "feature_name" in status
        assert status["feature_name"] == "new_feature"
```

### 統合テスト

```python
# /app/tests/features/test_new_feature/test_integration.py
import pytest
from modules.new_feature.services.implementation import NewFeatureService
from src.infrastructure.database.services.base_repository import BaseRepository

class TestNewFeatureIntegration:
    """新機能の統合テスト"""

    @pytest.fixture
    async def service(self):
        """統合テスト用サービス"""
        repository = BaseRepository()
        service = NewFeatureService(repository)
        await service.initialize()
        yield service
        await service.cleanup()

    async def test_full_workflow(self, service):
        """完全なワークフローテスト"""
        # 1. 初期化確認
        assert service.is_initialized is True

        # 2. 実行テスト
        result = await service.execute({"param": "integration_test"})
        assert result["status"] == "success"

        # 3. ステータス確認
        status = service.get_status()
        assert status["initialized"] is True

    async def test_error_handling(self, service):
        """エラーハンドリングテスト"""
        # 無効なパラメータでの実行
        result = await service.execute({"invalid": "param"})
        # エラーハンドリングの実装に応じてテストを調整
        assert "status" in result
```

### テスト実行コマンド

```bash
# 基幹モジュールのテスト
pytest tests/core/ -v

# 機能別テスト
pytest tests/features/test_new_feature/ -v

# 全テスト実行
pytest tests/ -v

# カバレッジ付きテスト
pytest tests/ --cov=src --cov=modules --cov-report=html
```

## デプロイメント戦略

### 段階的デプロイ

```yaml
# deployment/feature_deployment.yaml
stages:
  development:
    modules: ["core", "new_feature_dev"]
    config: "config/features/new_feature_dev.py"
    environment: "development"
    tests: ["unit", "integration"]

  staging:
    modules: ["core", "new_feature_staging"]
    config: "config/features/new_feature_staging.py"
    environment: "staging"
    tests: ["unit", "integration", "e2e"]

  production:
    modules: ["core", "new_feature_prod"]
    config: "config/features/new_feature_prod.py"
    environment: "production"
    tests: ["unit", "integration", "e2e", "performance"]
```

### 機能フラグ

```python
# /app/modules/feature_flags.py
import os
from typing import Dict, Any

class FeatureFlags:
    """機能フラグ管理"""

    def __init__(self):
        self.flags = {
            "new_feature": {
                "enabled": os.getenv("NEW_FEATURE_ENABLED", "false").lower() == "true",
                "percentage": int(os.getenv("NEW_FEATURE_PERCENTAGE", "0")),
                "user_groups": os.getenv("NEW_FEATURE_USER_GROUPS", "").split(",")
            }
        }

    def is_enabled(self, feature_name: str, user_id: str = None) -> bool:
        """機能が有効かチェック"""
        if feature_name not in self.flags:
            return False

        flag = self.flags[feature_name]

        # 基本の有効/無効チェック
        if not flag["enabled"]:
            return False

        # パーセンテージベースの有効化
        if flag["percentage"] > 0 and user_id:
            # ユーザーIDに基づくパーセンテージ計算
            user_hash = hash(user_id) % 100
            if user_hash >= flag["percentage"]:
                return False

        # ユーザーグループベースの有効化
        if flag["user_groups"] and user_id:
            # ユーザーグループのチェック実装
            pass

        return True

    def get_feature_config(self, feature_name: str) -> Dict[str, Any]:
        """機能設定を取得"""
        return self.flags.get(feature_name, {})
```

### デプロイスクリプト

```bash
#!/bin/bash
# /app/scripts/deployment/deploy_feature.sh

FEATURE_NAME=$1
ENVIRONMENT=$2

echo "🚀 機能デプロイ開始: $FEATURE_NAME (環境: $ENVIRONMENT)"

# 1. テスト実行
echo "📋 テスト実行中..."
pytest tests/features/test_$FEATURE_NAME/ -v
if [ $? -ne 0 ]; then
    echo "❌ テストが失敗しました"
    exit 1
fi

# 2. 設定確認
echo "⚙️ 設定確認中..."
python -c "from config.features.$FEATURE_NAME import *; print('設定OK')"
if [ $? -ne 0 ]; then
    echo "❌ 設定エラー"
    exit 1
fi

# 3. 機能フラグ設定
echo "🏁 機能フラグ設定中..."
export ${FEATURE_NAME^^}_ENABLED=true

# 4. デプロイ実行
echo "📦 デプロイ実行中..."
# 実際のデプロイ処理

echo "✅ デプロイ完了"
```

## 監視・ログ・メトリクス

### ログの分離

```python
# /app/modules/new_feature/utils/logging.py
import logging
from ...src.utils.logging_config import get_logger

def get_feature_logger(feature_name: str) -> logging.Logger:
    """機能別ロガーを取得"""
    logger = get_logger(f"feature.{feature_name}")
    logger.setLevel(logging.INFO)

    # 機能別ログファイル
    handler = logging.FileHandler(f"/app/logs/features/{feature_name}.log")
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    handler.setFormatter(formatter)
    logger.addHandler(handler)

    return logger

# 使用例
logger = get_feature_logger("new_feature")
logger.info("新機能が開始されました")
logger.error("エラーが発生しました")
```

### メトリクス（測定指標）の説明

**メトリクスとは**: システムの性能や状態を数値で表した指標のことです。

#### 基本的なメトリクス

```python
# /app/modules/new_feature/monitoring/metrics.py
import time
from typing import Dict, Any
from collections import defaultdict

class NewFeatureMetrics:
    """新機能のメトリクス収集クラス"""

    def __init__(self):
        # 実行回数
        self.execution_count = 0

        # 成功・失敗回数
        self.success_count = 0
        self.error_count = 0

        # 実行時間
        self.execution_times = []

        # エラー詳細
        self.error_details = defaultdict(int)

        # リソース使用量
        self.memory_usage = []
        self.cpu_usage = []

    def record_execution(self, success: bool, execution_time: float, error_type: str = None):
        """実行結果を記録"""
        self.execution_count += 1

        if success:
            self.success_count += 1
        else:
            self.error_count += 1
            if error_type:
                self.error_details[error_type] += 1

        self.execution_times.append(execution_time)

    def record_resource_usage(self, memory_mb: float, cpu_percent: float):
        """リソース使用量を記録"""
        self.memory_usage.append(memory_mb)
        self.cpu_usage.append(cpu_percent)

    def get_metrics(self) -> Dict[str, Any]:
        """メトリクスを取得"""
        avg_execution_time = sum(self.execution_times) / len(self.execution_times) if self.execution_times else 0
        success_rate = self.success_count / max(self.execution_count, 1)

        return {
            # 基本統計
            "execution_count": self.execution_count,
            "success_count": self.success_count,
            "error_count": self.error_count,
            "success_rate": success_rate,

            # パフォーマンス
            "avg_execution_time": avg_execution_time,
            "max_execution_time": max(self.execution_times) if self.execution_times else 0,
            "min_execution_time": min(self.execution_times) if self.execution_times else 0,

            # エラー詳細
            "error_details": dict(self.error_details),

            # リソース使用量
            "avg_memory_usage": sum(self.memory_usage) / len(self.memory_usage) if self.memory_usage else 0,
            "avg_cpu_usage": sum(self.cpu_usage) / len(self.cpu_usage) if self.cpu_usage else 0,
        }

    def reset_metrics(self):
        """メトリクスをリセット"""
        self.execution_count = 0
        self.success_count = 0
        self.error_count = 0
        self.execution_times.clear()
        self.error_details.clear()
        self.memory_usage.clear()
        self.cpu_usage.clear()
```

#### メトリクスの種類と意味

1. **実行回数メトリクス**

   - `execution_count`: 総実行回数
   - `success_count`: 成功回数
   - `error_count`: 失敗回数
   - `success_rate`: 成功率（成功回数 ÷ 総実行回数）

2. **パフォーマンスメトリクス**

   - `avg_execution_time`: 平均実行時間
   - `max_execution_time`: 最大実行時間
   - `min_execution_time`: 最小実行時間

3. **リソース使用量メトリクス**

   - `avg_memory_usage`: 平均メモリ使用量
   - `avg_cpu_usage`: 平均 CPU 使用率

4. **エラーメトリクス**
   - `error_details`: エラー種類別の発生回数

### 監視システムとの統合

```python
# /app/modules/new_feature/monitoring/integration.py
from .metrics import NewFeatureMetrics
from ...src.infrastructure.monitoring.performance_monitor import PerformanceMonitor

class FeatureMonitoringIntegration:
    """機能監視の統合クラス"""

    def __init__(self, feature_name: str):
        self.feature_name = feature_name
        self.metrics = NewFeatureMetrics()
        self.performance_monitor = PerformanceMonitor()

    async def start_monitoring(self):
        """監視開始"""
        # 基幹監視システムに機能を登録
        await self.performance_monitor.register_feature(self.feature_name)

    async def record_feature_execution(self, success: bool, execution_time: float):
        """機能実行を記録"""
        # 機能固有のメトリクスに記録
        self.metrics.record_execution(success, execution_time)

        # 基幹監視システムにも記録
        await self.performance_monitor.record_feature_metric(
            self.feature_name,
            "execution",
            {"success": success, "time": execution_time}
        )

    async def get_feature_health(self) -> Dict[str, Any]:
        """機能の健全性を取得"""
        metrics = self.metrics.get_metrics()

        # 健全性判定
        health_status = "healthy"
        if metrics["success_rate"] < 0.95:  # 成功率95%未満
            health_status = "warning"
        if metrics["success_rate"] < 0.90:  # 成功率90%未満
            health_status = "critical"

        return {
            "feature_name": self.feature_name,
            "health_status": health_status,
            "metrics": metrics,
            "timestamp": time.time()
        }
```

### アラート設定

```python
# /app/modules/new_feature/monitoring/alerts.py
class FeatureAlerts:
    """機能別アラート設定"""

    def __init__(self, feature_name: str):
        self.feature_name = feature_name
        self.alert_thresholds = {
            "success_rate": 0.90,      # 成功率90%未満でアラート
            "execution_time": 5.0,     # 実行時間5秒超過でアラート
            "error_count": 10,         # エラー10回でアラート
        }

    def check_alerts(self, metrics: Dict[str, Any]) -> list:
        """アラート条件をチェック"""
        alerts = []

        # 成功率アラート
        if metrics["success_rate"] < self.alert_thresholds["success_rate"]:
            alerts.append({
                "type": "low_success_rate",
                "message": f"成功率が低下: {metrics['success_rate']:.2%}",
                "severity": "warning"
            })

        # 実行時間アラート
        if metrics["avg_execution_time"] > self.alert_thresholds["execution_time"]:
            alerts.append({
                "type": "slow_execution",
                "message": f"実行時間が長い: {metrics['avg_execution_time']:.2f}秒",
                "severity": "warning"
            })

        # エラー数アラート
        if metrics["error_count"] > self.alert_thresholds["error_count"]:
            alerts.append({
                "type": "high_error_count",
                "message": f"エラー数が多い: {metrics['error_count']}回",
                "severity": "critical"
            })

        return alerts
```

## 実装の優先順位

### 1. 高優先度（即座実装）

```bash
# ディレクトリ構造の整備
mkdir -p /app/modules/{interfaces,services,handlers,tests,config}
mkdir -p /app/config/features
mkdir -p /app/tests/{core,features}
mkdir -p /app/requirements/features

# 基本ファイルの作成
touch /app/modules/__init__.py
touch /app/config/features/__init__.py
touch /app/tests/features/__init__.py
```

### 2. 中優先度（1-2 週間以内）

- **インターフェース設計**: 新機能の標準インターフェース
- **設定管理クラス**: 機能別設定の管理
- **テストフレームワーク**: 機能別テストの整備
- **ログ・監視**: 機能別ログ・メトリクス

### 3. 低優先度（1 ヶ月以内）

- **デプロイメント自動化**: 段階的デプロイ
- **機能フラグ**: 動的な機能の有効/無効切り替え
- **ドキュメント**: 機能追加ガイド
- **CI/CD**: 機能別ビルド・テスト

## まとめ

### このワークフローの利点

1. **基幹モジュールの完全保護**

   - 既存システムの安定性を維持
   - 破壊的変更のリスクを排除

2. **新機能の独立性**

   - 機能の追加・削除が容易
   - 他の機能への影響を最小化

3. **段階的開発**

   - リスクを最小化した開発
   - テスト可能な小さな単位での実装

4. **保守性の向上**

   - 機能別の責任分離
   - 明確なインターフェース設計

5. **拡張性の確保**
   - 新機能の追加が容易
   - 既存機能の再利用

### 次のステップ

1. **ディレクトリ構造の整備**
2. **最初の新機能モジュールの実装**
3. **テストフレームワークの構築**
4. **監視・ログシステムの統合**

このワークフローに従うことで、基幹モジュールを保護しながら、安全で効率的な機能拡張が可能になります。
