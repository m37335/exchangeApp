# 🚨 プロトレーダー向け為替アラートシステム設計書

**プロジェクト名**: Exchange Analytics System - プロトレーダー向けアラートシステム  
**作成日**: 2025 年 1 月 15 日  
**バージョン**: 1.0.0  
**目的**: プロトレーダーの実戦的なニーズに応えるアラートシステムの設計・実装

## 📋 概要

### 背景

現在のテクニカル指標テーブル（`technical_indicators`）には豊富なデータが蓄積されており、これを活用してプロトレーダーが実際に活用できるアラートシステムを構築する必要がある。

### 目標

- **実戦的なエントリー/エグジットシグナル**の提供
- **リスク管理**に基づくアラート設計
- **複数タイムフレーム**での統合分析
- **パフォーマンス追跡**による継続的改善

### 対象ユーザー

- **スキャルピング**: 1-5 分足での即座の判断
- **デイトレード**: 15 分-1 時間足でのエントリー/エグジット
- **スイングトレード**: 4 時間-日足でのトレンド判断
- **ポジショントレード**: 週足-月足での大トレンド

## 🏗️ システムアーキテクチャ

### 全体構成

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Data Source   │───►│  Alert Engine   │───►│ Notification    │
│ (technical_     │    │                 │    │ System          │
│  indicators)    │    │                 │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  Signal Store   │    │  Risk Manager   │    │  Performance    │
│                 │    │                 │    │  Tracker        │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### コンポーネント詳細

#### 1. アラートエンジン（Alert Engine）

- **責任**: シグナル検出、条件判定、アラート生成
- **入力**: テクニカル指標データ
- **出力**: アラートオブジェクト

#### 2. リスクマネージャー（Risk Manager）

- **責任**: リスク評価、ポジションサイズ計算、ストップロス設定
- **入力**: アラートシグナル、アカウント情報
- **出力**: リスク調整済みシグナル

#### 3. 通知システム（Notification System）

- **責任**: マルチチャンネル通知、メッセージフォーマット
- **入力**: アラートオブジェクト
- **出力**: Discord/メール/Slack 通知

#### 4. パフォーマンストラッカー（Performance Tracker）

- **責任**: シグナルパフォーマンス追跡、統計分析
- **入力**: アラート履歴、実際の取引結果
- **出力**: パフォーマンスレポート

## 🗄️ データベース設計

### 新規テーブル

#### 1. アラート設定テーブル（alert_settings）

```sql
CREATE TABLE alert_settings (
    id SERIAL PRIMARY KEY,
    alert_type VARCHAR(50) NOT NULL,           -- 'entry_signal', 'exit_signal', 'risk_alert'
    indicator_type VARCHAR(20),                -- 'RSI', 'MACD', 'BB', 'MA'
    timeframe VARCHAR(10),                     -- 'M5', 'M15', 'H1', 'H4', 'D1'
    threshold_value DECIMAL(15, 8),            -- 閾値
    condition_type VARCHAR(20),                -- 'above', 'below', 'cross', 'divergence'
    risk_reward_min DECIMAL(5, 2),             -- 最小リスク/リワード比
    confidence_min INTEGER,                    -- 最小信頼度（0-100）
    is_active BOOLEAN DEFAULT TRUE,
    notification_channels JSONB,               -- ['discord', 'email', 'slack']
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT idx_alert_settings_unique UNIQUE (alert_type, indicator_type, timeframe)
);
```

#### 2. エントリーシグナルテーブル（entry_signals）

```sql
CREATE TABLE entry_signals (
    id SERIAL PRIMARY KEY,
    signal_type VARCHAR(10) NOT NULL,          -- 'BUY', 'SELL'
    currency_pair VARCHAR(10) NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
    timeframe VARCHAR(10) NOT NULL,

    -- 価格情報
    entry_price DECIMAL(10, 5) NOT NULL,
    stop_loss DECIMAL(10, 5) NOT NULL,
    take_profit DECIMAL(10, 5) NOT NULL,

    -- リスク管理
    risk_reward_ratio DECIMAL(5, 2) NOT NULL,
    risk_amount DECIMAL(10, 2),                -- リスク額（USD）
    position_size DECIMAL(10, 2),              -- 推奨ポジションサイズ

    -- 分析情報
    confidence_score INTEGER NOT NULL,         -- 0-100
    indicators_used JSONB NOT NULL,            -- 使用した指標
    market_conditions JSONB,                   -- 市場状況
    trend_strength DECIMAL(5, 2),              -- トレンド強度

    -- 管理情報
    is_executed BOOLEAN DEFAULT FALSE,
    executed_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT idx_entry_signals_unique UNIQUE (currency_pair, timestamp, signal_type, timeframe)
);
```

#### 3. リスクアラートテーブル（risk_alerts）

```sql
CREATE TABLE risk_alerts (
    id SERIAL PRIMARY KEY,
    alert_type VARCHAR(50) NOT NULL,           -- 'volatility_spike', 'correlation_change', 'liquidity_warning'
    currency_pair VARCHAR(10) NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
    timeframe VARCHAR(10) NOT NULL,

    -- アラート情報
    severity VARCHAR(10) NOT NULL,             -- 'LOW', 'MEDIUM', 'HIGH', 'CRITICAL'
    message TEXT NOT NULL,
    recommended_action TEXT,

    -- データ
    market_data JSONB NOT NULL,                -- 市場データ
    threshold_value DECIMAL(15, 8),            -- 閾値
    current_value DECIMAL(15, 8),              -- 現在値

    -- 管理情報
    is_acknowledged BOOLEAN DEFAULT FALSE,
    acknowledged_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```

#### 4. シグナルパフォーマンステーブル（signal_performance）

```sql
CREATE TABLE signal_performance (
    id SERIAL PRIMARY KEY,
    signal_id INTEGER REFERENCES entry_signals(id),
    currency_pair VARCHAR(10) NOT NULL,
    timeframe VARCHAR(10) NOT NULL,

    -- 取引情報
    entry_time TIMESTAMP WITH TIME ZONE NOT NULL,
    exit_time TIMESTAMP WITH TIME ZONE,
    entry_price DECIMAL(10, 5) NOT NULL,
    exit_price DECIMAL(10, 5),

    -- 結果
    pnl DECIMAL(10, 5),                        -- 損益
    pnl_percentage DECIMAL(5, 2),              -- 損益率（%）
    exit_reason VARCHAR(50),                   -- 'take_profit', 'stop_loss', 'manual', 'trend_change'

    -- 統計
    duration_minutes INTEGER,                  -- 保有時間（分）
    max_profit DECIMAL(10, 5),                 -- 最大利益
    max_loss DECIMAL(10, 5),                   -- 最大損失
    drawdown DECIMAL(5, 2),                    -- 最大ドローダウン（%）

    -- 管理情報
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```

### インデックス設計

```sql
-- エントリーシグナル
CREATE INDEX idx_entry_signals_timestamp ON entry_signals (timestamp DESC);
CREATE INDEX idx_entry_signals_currency_timeframe ON entry_signals (currency_pair, timeframe);
CREATE INDEX idx_entry_signals_executed ON entry_signals (is_executed, timestamp);
CREATE INDEX idx_entry_signals_confidence ON entry_signals (confidence_score DESC);

-- リスクアラート
CREATE INDEX idx_risk_alerts_severity ON risk_alerts (severity, timestamp DESC);
CREATE INDEX idx_risk_alerts_currency ON risk_alerts (currency_pair, timestamp DESC);
CREATE INDEX idx_risk_alerts_acknowledged ON risk_alerts (is_acknowledged, timestamp);

-- パフォーマンス
CREATE INDEX idx_signal_performance_pnl ON signal_performance (pnl_percentage DESC);
CREATE INDEX idx_signal_performance_duration ON signal_performance (duration_minutes);
CREATE INDEX idx_signal_performance_exit_reason ON signal_performance (exit_reason);
```

## 🔍 アラート検出ロジック

### 1. エントリーシグナル検出

#### RSI + 移動平均線の組み合わせ

```python
class RSIEntryDetector:
    async def detect_rsi_entry_signals(self, timeframe: str) -> List[EntrySignal]:
        """
        RSIベースのエントリーシグナル検出

        買いシグナル条件:
        - RSI < 30 (過売り)
        - 価格 > SMA20 (上昇トレンド)
        - MACDヒストグラム > 0 (モメンタム上昇)
        - ボラティリティが適正範囲

        売りシグナル条件:
        - RSI > 70 (過買い)
        - 価格 < SMA20 (下降トレンド)
        - MACDヒストグラム < 0 (モメンタム下降)
        - ボラティリティが適正範囲
        """
        signals = []

        # 最新のテクニカル指標データを取得
        indicators = await self.get_latest_indicators(timeframe)

        if not indicators:
            return signals

        # RSI条件チェック
        rsi = indicators.get('RSI')
        sma_20 = indicators.get('SMA_20')
        macd_hist = indicators.get('MACD_histogram')
        atr = indicators.get('ATR')

        if all([rsi, sma_20, macd_hist, atr]):
            current_price = await self.get_current_price()

            # 買いシグナル
            if (rsi < 30 and
                current_price > sma_20 and
                macd_hist > 0 and
                self.is_volatility_normal(atr)):

                signal = EntrySignal(
                    signal_type="BUY",
                    entry_price=current_price,
                    stop_loss=sma_20 * 0.995,  # 0.5%下
                    take_profit=current_price * 1.015,  # 1.5%上
                    risk_reward_ratio=3.0,
                    confidence_score=self.calculate_confidence(indicators),
                    indicators_used={
                        "RSI": rsi,
                        "SMA_20": sma_20,
                        "MACD_histogram": macd_hist,
                        "ATR": atr
                    }
                )
                signals.append(signal)

            # 売りシグナル
            elif (rsi > 70 and
                  current_price < sma_20 and
                  macd_hist < 0 and
                  self.is_volatility_normal(atr)):

                signal = EntrySignal(
                    signal_type="SELL",
                    entry_price=current_price,
                    stop_loss=sma_20 * 1.005,  # 0.5%上
                    take_profit=current_price * 0.985,  # 1.5%下
                    risk_reward_ratio=3.0,
                    confidence_score=self.calculate_confidence(indicators),
                    indicators_used={
                        "RSI": rsi,
                        "SMA_20": sma_20,
                        "MACD_histogram": macd_hist,
                        "ATR": atr
                    }
                )
                signals.append(signal)

        return signals
```

#### ボリンジャーバンド + モメンタム

```python
class BollingerBandsEntryDetector:
    async def detect_bb_entry_signals(self, timeframe: str) -> List[EntrySignal]:
        """
        ボリンジャーバンドベースのエントリーシグナル検出

        買いシグナル条件:
        - 価格が下バンドにタッチ
        - RSI < 40 (過売り傾向)
        - 出来高 > 平均出来高の1.5倍

        売りシグナル条件:
        - 価格が上バンドにタッチ
        - RSI > 60 (過買い傾向)
        - 出来高 > 平均出来高の1.5倍
        """
        signals = []

        indicators = await self.get_latest_indicators(timeframe)

        if not indicators:
            return signals

        bb_upper = indicators.get('BB_upper')
        bb_lower = indicators.get('BB_lower')
        bb_middle = indicators.get('BB_middle')
        rsi = indicators.get('RSI')
        volume = indicators.get('volume')
        avg_volume = indicators.get('avg_volume')

        if all([bb_upper, bb_lower, bb_middle, rsi, volume, avg_volume]):
            current_price = await self.get_current_price()

            # 買いシグナル（下バンドタッチ）
            if (current_price <= bb_lower * 1.001 and  # 0.1%以内
                rsi < 40 and
                volume > avg_volume * 1.5):

                signal = EntrySignal(
                    signal_type="BUY",
                    entry_price=current_price,
                    stop_loss=bb_lower * 0.995,  # 下バンドの0.5%下
                    take_profit=bb_middle,  # ミドルバンド
                    risk_reward_ratio=2.5,
                    confidence_score=self.calculate_bb_confidence(indicators),
                    indicators_used={
                        "BB_upper": bb_upper,
                        "BB_lower": bb_lower,
                        "BB_middle": bb_middle,
                        "RSI": rsi,
                        "volume": volume,
                        "avg_volume": avg_volume
                    }
                )
                signals.append(signal)

            # 売りシグナル（上バンドタッチ）
            elif (current_price >= bb_upper * 0.999 and  # 0.1%以内
                  rsi > 60 and
                  volume > avg_volume * 1.5):

                signal = EntrySignal(
                    signal_type="SELL",
                    entry_price=current_price,
                    stop_loss=bb_upper * 1.005,  # 上バンドの0.5%上
                    take_profit=bb_middle,  # ミドルバンド
                    risk_reward_ratio=2.5,
                    confidence_score=self.calculate_bb_confidence(indicators),
                    indicators_used={
                        "BB_upper": bb_upper,
                        "BB_lower": bb_lower,
                        "BB_middle": bb_middle,
                        "RSI": rsi,
                        "volume": volume,
                        "avg_volume": avg_volume
                    }
                )
                signals.append(signal)

        return signals
```

### 2. リスク管理アラート

#### ボラティリティ急増検出

```python
class VolatilityRiskDetector:
    async def detect_volatility_risk(self, timeframe: str) -> List[RiskAlert]:
        """
        ボラティリティリスク検出

        アラート条件:
        - ATRが過去20期間平均の2倍以上
        - 価格変動が過去24時間で3%以上
        - 出来高が過去平均の3倍以上
        """
        alerts = []

        # ATRデータを取得
        atr_data = await self.get_atr_data(timeframe, periods=20)
        if len(atr_data) < 20:
            return alerts

        current_atr = atr_data[-1]
        avg_atr = sum(atr_data[:-1]) / len(atr_data[:-1])

        # 価格変動データを取得
        price_change_24h = await self.get_price_change_24h()
        volume_ratio = await self.get_volume_ratio()

        # ボラティリティ急増チェック
        if (current_atr > avg_atr * 2.0 or
            abs(price_change_24h) > 3.0 or
            volume_ratio > 3.0):

            severity = "CRITICAL" if current_atr > avg_atr * 3.0 else "HIGH"

            alert = RiskAlert(
                alert_type="volatility_spike",
                severity=severity,
                message=f"ボラティリティ急増検出: ATR={current_atr:.5f} (平均: {avg_atr:.5f})",
                recommended_action="ポジションサイズを50%削減、ストップロスを広げる",
                market_data={
                    "current_atr": current_atr,
                    "avg_atr": avg_atr,
                    "price_change_24h": price_change_24h,
                    "volume_ratio": volume_ratio
                },
                threshold_value=avg_atr * 2.0,
                current_value=current_atr
            )
            alerts.append(alert)

        return alerts
```

#### 相関性変化検出

```python
class CorrelationRiskDetector:
    async def detect_correlation_risk(self) -> List[RiskAlert]:
        """
        通貨ペア間の相関性変化検出

        アラート条件:
        - USD/JPYとEUR/USDの相関が0.8以上
        - 相関が過去30日で0.3以上変化
        """
        alerts = []

        # 相関データを取得
        correlation_data = await self.get_correlation_data("USD/JPY", "EUR/USD", days=30)
        if len(correlation_data) < 30:
            return alerts

        current_correlation = correlation_data[-1]
        avg_correlation = sum(correlation_data[:-1]) / len(correlation_data[:-1])
        correlation_change = abs(current_correlation - avg_correlation)

        # 高相関チェック
        if current_correlation > 0.8:
            alert = RiskAlert(
                alert_type="high_correlation",
                severity="MEDIUM",
                message=f"高相関検出: USD/JPY-EUR/USD相関={current_correlation:.3f}",
                recommended_action="ポジションの分散化を検討",
                market_data={
                    "current_correlation": current_correlation,
                    "avg_correlation": avg_correlation,
                    "correlation_change": correlation_change
                },
                threshold_value=0.8,
                current_value=current_correlation
            )
            alerts.append(alert)

        # 相関変化チェック
        if correlation_change > 0.3:
            alert = RiskAlert(
                alert_type="correlation_change",
                severity="HIGH",
                message=f"相関性急変: 変化幅={correlation_change:.3f}",
                recommended_action="既存ポジションの見直し",
                market_data={
                    "current_correlation": current_correlation,
                    "avg_correlation": avg_correlation,
                    "correlation_change": correlation_change
                },
                threshold_value=0.3,
                current_value=correlation_change
            )
            alerts.append(alert)

        return alerts
```

## 📱 通知システム設計

### Discord 通知フォーマット

#### エントリーシグナル通知

```python
class DiscordNotificationService:
    def format_entry_signal(self, signal: EntrySignal) -> str:
        """
        エントリーシグナルをDiscord用にフォーマット
        """
        emoji_map = {
            "BUY": "🟢",
            "SELL": "🔴"
        }

        signal_emoji = emoji_map.get(signal.signal_type, "⚪")

        message = f"""
{signal_emoji} **USD/JPY {signal.signal_type}エントリーシグナル**

💰 **価格情報**
• エントリー: {signal.entry_price:.3f}
• ストップロス: {signal.stop_loss:.3f} ({self.calculate_stop_distance(signal):.2f}%)
• 利益確定: {signal.take_profit:.3f} ({self.calculate_profit_distance(signal):.2f}%)

⚖️ **リスク管理**
• リスク/リワード比: {signal.risk_reward_ratio}:1
• 信頼度: {signal.confidence_score}%
• 推奨ポジションサイズ: {signal.position_size:.2f}%

📊 **指標状況**
{self.format_indicators(signal.indicators_used)}

⚠️ **注意事項**
• 有効期限: 30分
• 市場状況: {self.get_market_condition()}
• 推奨アクション: {self.get_recommended_action(signal)}

🕐 **生成時刻**: {signal.timestamp.strftime('%Y-%m-%d %H:%M:%S JST')}
        """

        return message.strip()
```

#### リスクアラート通知

```python
def format_risk_alert(self, alert: RiskAlert) -> str:
    """
    リスクアラートをDiscord用にフォーマット
    """
    severity_emoji = {
        "LOW": "🟡",
        "MEDIUM": "🟠",
        "HIGH": "🔴",
        "CRITICAL": "🚨"
    }

    emoji = severity_emoji.get(alert.severity, "⚪")

    message = f"""
{emoji} **リスクアラート: {alert.alert_type.replace('_', ' ').title()}**

📋 **アラート内容**
{alert.message}

🎯 **推奨アクション**
{alert.recommended_action}

📊 **詳細データ**
{self.format_market_data(alert.market_data)}

⚠️ **重要度**: {alert.severity}
🕐 **検出時刻**: {alert.timestamp.strftime('%Y-%m-%d %H:%M:%S JST')}
        """

    return message.strip()
```

### メール通知フォーマット

```python
class EmailNotificationService:
    def format_daily_summary(self, date: datetime) -> str:
        """
        日次サマリーをメール用にフォーマット
        """
        # 日次統計を取得
        stats = self.get_daily_statistics(date)

        message = f"""
# USD/JPY トレーディングサマリー - {date.strftime('%Y-%m-%d')}

## 📊 シグナル統計
- 生成シグナル数: {stats['total_signals']}
- 実行シグナル数: {stats['executed_signals']}
- 成功率: {stats['success_rate']:.1f}%
- 平均損益: {stats['avg_pnl']:.2f}%

## 🚨 リスクアラート
- 高重要度アラート: {stats['high_risk_alerts']}
- 中重要度アラート: {stats['medium_risk_alerts']}
- 低重要度アラート: {stats['low_risk_alerts']}

## 📈 パフォーマンス分析
- 最良シグナル: {stats['best_signal']}
- 最悪シグナル: {stats['worst_signal']}
- 平均保有時間: {stats['avg_duration']}分

## 🔮 明日の予測
{stats['tomorrow_prediction']}
        """

        return message.strip()
```

## 🔧 実装計画

### Phase 1: 基本アラートシステム（1-2 週間）

#### Week 1: データベース・モデル実装

- [ ] アラート設定テーブル作成
- [ ] エントリーシグナルテーブル作成
- [ ] リスクアラートテーブル作成
- [ ] シグナルパフォーマンステーブル作成
- [ ] SQLAlchemy モデル実装

#### Week 2: 基本検出エンジン実装

- [ ] RSI エントリー検出器実装
- [ ] ボリンジャーバンドエントリー検出器実装
- [ ] ボラティリティリスク検出器実装
- [ ] 基本通知システム実装

### Phase 2: 高度な検出機能（2-3 週間）

#### Week 3: 複数タイムフレーム分析

- [ ] マルチタイムフレーム統合分析
- [ ] トレンド強度計算
- [ ] 相関性分析実装

#### Week 4: リスク管理強化

- [ ] ポジションサイズ計算
- [ ] 動的ストップロス調整
- [ ] ポートフォリオリスク管理

### Phase 3: パフォーマンス・最適化（1-2 週間）

#### Week 5: パフォーマンス追跡

- [ ] シグナルパフォーマンス追跡
- [ ] 統計分析機能
- [ ] バックテスト機能

#### Week 6: システム最適化

- [ ] パフォーマンス最適化
- [ ] エラーハンドリング強化
- [ ] 監視・ログ機能強化

## 📊 成功指標

### 技術指標

- **レスポンス時間**: アラート生成 < 5 秒
- **精度**: シグナル成功率 > 60%
- **可用性**: システム稼働率 > 99.5%

### ビジネス指標

- **ユーザー満足度**: アラート有用性評価 > 4.0/5.0
- **使用率**: 日次アクティブユーザー > 80%
- **収益性**: 平均リスク/リワード比 > 2.0

## 🚨 リスク・課題

### 技術的リスク

- **誤検知**: ノイズによる誤シグナル
- **レイテンシ**: リアルタイム処理の遅延
- **スケーラビリティ**: 大量データ処理の負荷

### 対策

- **フィルタリング**: 複数指標による確認
- **最適化**: アルゴリズム・インデックス最適化
- **分散処理**: 非同期処理・キャッシュ活用

## 📋 今後の展開

### 短期（3 ヶ月以内）

- 機械学習による予測精度向上
- 多通貨ペア対応
- モバイルアプリ開発

### 中期（6 ヶ月以内）

- ソーシャルトレーディング機能
- 自動売買システム連携
- 高度なリスク管理機能

### 長期（1 年以内）

- AI による市場予測
- ブロックチェーン統合
- グローバル展開

---

**作成日**: 2025 年 1 月 15 日  
**更新日**: 2025 年 1 月 15 日  
**作成者**: AI Assistant  
**バージョン**: 1.0.0  
**ステータス**: 設計完了
