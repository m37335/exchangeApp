# Infrastructure Layer & Plugin System 詳細設計

**作成日**: 2025 年 8 月 9 日
**対象**: インフラ層とプラグインシステムの詳細設計
**依存関係**: Application Layer のインターフェースを実装

## 1. Infrastructure Layer 構成

```
src/infrastructure/
├── database/           # データベース実装
├── external_apis/      # 外部API実装
├── messaging/          # メッセージング・通知
├── cache/             # キャッシュ実装
├── monitoring/        # モニタリング
└── config/           # 設定管理
```

## 2. Database Layer

### 2.1 Repository Implementation

#### src/infrastructure/database/repositories/base_repository.py

```python
"""ベースリポジトリ実装"""
import asyncio
from typing import Optional, List, Dict, Any, TypeVar, Type
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, delete, func
from sqlalchemy.orm import selectinload
from ...domain.repositories.base import BaseRepository
from ..models import BaseModel
import logging

logger = logging.getLogger(__name__)
T = TypeVar('T')

class BaseRepositoryImpl(BaseRepository[T]):
    """ベースリポジトリ実装クラス"""

    def __init__(
        self,
        session: AsyncSession,
        model_class: Type[BaseModel],
        entity_class: Type[T]
    ):
        self.session = session
        self.model_class = model_class
        self.entity_class = entity_class

    async def find_by_id(self, entity_id: int) -> Optional[T]:
        """IDで検索"""
        try:
            result = await self.session.execute(
                select(self.model_class).where(self.model_class.id == entity_id)
            )
            model = result.scalar_one_or_none()
            return self._model_to_entity(model) if model else None
        except Exception as e:
            logger.error(f"Error finding entity by id {entity_id}: {str(e)}")
            raise

    async def find_by_uuid(self, uuid: str) -> Optional[T]:
        """UUIDで検索"""
        try:
            result = await self.session.execute(
                select(self.model_class).where(self.model_class.uuid == uuid)
            )
            model = result.scalar_one_or_none()
            return self._model_to_entity(model) if model else None
        except Exception as e:
            logger.error(f"Error finding entity by uuid {uuid}: {str(e)}")
            raise

    async def find_all(self, limit: int = 100, offset: int = 0) -> List[T]:
        """全件検索"""
        try:
            result = await self.session.execute(
                select(self.model_class)
                .limit(limit)
                .offset(offset)
                .order_by(self.model_class.created_at.desc())
            )
            models = result.scalars().all()
            return [self._model_to_entity(model) for model in models]
        except Exception as e:
            logger.error(f"Error finding all entities: {str(e)}")
            raise

    async def save(self, entity: T) -> T:
        """保存"""
        try:
            model = self._entity_to_model(entity)
            self.session.add(model)
            await self.session.commit()
            await self.session.refresh(model)
            return self._model_to_entity(model)
        except Exception as e:
            await self.session.rollback()
            logger.error(f"Error saving entity: {str(e)}")
            raise

    async def update(self, entity: T) -> T:
        """更新"""
        try:
            entity.update_version()  # バージョン更新
            model_data = self._entity_to_dict(entity)

            await self.session.execute(
                update(self.model_class)
                .where(self.model_class.id == entity.id)
                .values(**model_data)
            )
            await self.session.commit()

            # 更新後のエンティティを再取得
            return await self.find_by_id(entity.id)
        except Exception as e:
            await self.session.rollback()
            logger.error(f"Error updating entity {entity.id}: {str(e)}")
            raise

    async def delete(self, entity_id: int) -> bool:
        """削除"""
        try:
            result = await self.session.execute(
                delete(self.model_class).where(self.model_class.id == entity_id)
            )
            await self.session.commit()
            return result.rowcount > 0
        except Exception as e:
            await self.session.rollback()
            logger.error(f"Error deleting entity {entity_id}: {str(e)}")
            raise

    async def exists(self, entity_id: int) -> bool:
        """存在確認"""
        try:
            result = await self.session.execute(
                select(func.count(self.model_class.id))
                .where(self.model_class.id == entity_id)
            )
            count = result.scalar()
            return count > 0
        except Exception as e:
            logger.error(f"Error checking existence of entity {entity_id}: {str(e)}")
            raise

    async def count(self, filters: Optional[Dict[str, Any]] = None) -> int:
        """件数カウント"""
        try:
            query = select(func.count(self.model_class.id))

            if filters:
                for field, value in filters.items():
                    if hasattr(self.model_class, field):
                        query = query.where(getattr(self.model_class, field) == value)

            result = await self.session.execute(query)
            return result.scalar()
        except Exception as e:
            logger.error(f"Error counting entities: {str(e)}")
            raise

    async def bulk_save(self, entities: List[T]) -> List[T]:
        """一括保存"""
        try:
            models = [self._entity_to_model(entity) for entity in entities]
            self.session.add_all(models)
            await self.session.commit()

            # ID付きエンティティを返す
            return [self._model_to_entity(model) for model in models]
        except Exception as e:
            await self.session.rollback()
            logger.error(f"Error bulk saving entities: {str(e)}")
            raise

    def _model_to_entity(self, model: BaseModel) -> T:
        """モデルからエンティティへ変換（サブクラスで実装）"""
        raise NotImplementedError("Subclasses must implement _model_to_entity")

    def _entity_to_model(self, entity: T) -> BaseModel:
        """エンティティからモデルへ変換（サブクラスで実装）"""
        raise NotImplementedError("Subclasses must implement _entity_to_model")

    def _entity_to_dict(self, entity: T) -> Dict[str, Any]:
        """エンティティから辞書へ変換（サブクラスで実装）"""
        raise NotImplementedError("Subclasses must implement _entity_to_dict")
```

#### src/infrastructure/database/repositories/exchange_rate_repository_impl.py

```python
"""為替レートリポジトリ実装"""
from typing import List, Optional
from datetime import datetime, date
from sqlalchemy import select, and_, desc
from sqlalchemy.ext.asyncio import AsyncSession
from ...domain.repositories.exchange_rate_repository import ExchangeRateRepository
from ...domain.entities.exchange_rate import ExchangeRate
from ...domain.value_objects.currency_pair import CurrencyPair
from ..models.exchange_rate_model import ExchangeRateModel
from .base_repository import BaseRepositoryImpl
import logging

logger = logging.getLogger(__name__)

class ExchangeRateRepositoryImpl(BaseRepositoryImpl[ExchangeRate], ExchangeRateRepository):
    """為替レートリポジトリ実装"""

    def __init__(self, session: AsyncSession):
        super().__init__(session, ExchangeRateModel, ExchangeRate)

    async def find_by_currency_pair(
        self,
        currency_pair: CurrencyPair,
        limit: int = 100
    ) -> List[ExchangeRate]:
        """通貨ペアで検索"""
        try:
            result = await self.session.execute(
                select(ExchangeRateModel)
                .where(ExchangeRateModel.currency_pair == currency_pair.to_string_no_slash())
                .order_by(desc(ExchangeRateModel.timestamp))
                .limit(limit)
            )
            models = result.scalars().all()
            return [self._model_to_entity(model) for model in models]
        except Exception as e:
            logger.error(f"Error finding rates for {currency_pair.to_string()}: {str(e)}")
            raise

    async def find_by_currency_pair_and_date_range(
        self,
        currency_pair: CurrencyPair,
        start_date: datetime,
        end_date: datetime
    ) -> List[ExchangeRate]:
        """通貨ペアと日付範囲で検索"""
        try:
            result = await self.session.execute(
                select(ExchangeRateModel)
                .where(
                    and_(
                        ExchangeRateModel.currency_pair == currency_pair.to_string_no_slash(),
                        ExchangeRateModel.timestamp >= start_date,
                        ExchangeRateModel.timestamp <= end_date
                    )
                )
                .order_by(ExchangeRateModel.timestamp)
            )
            models = result.scalars().all()
            return [self._model_to_entity(model) for model in models]
        except Exception as e:
            logger.error(
                f"Error finding rates for {currency_pair.to_string()} "
                f"between {start_date} and {end_date}: {str(e)}"
            )
            raise

    async def find_latest_by_currency_pair(
        self,
        currency_pair: CurrencyPair
    ) -> Optional[ExchangeRate]:
        """通貨ペアの最新レート取得"""
        try:
            result = await self.session.execute(
                select(ExchangeRateModel)
                .where(ExchangeRateModel.currency_pair == currency_pair.to_string_no_slash())
                .order_by(desc(ExchangeRateModel.timestamp))
                .limit(1)
            )
            model = result.scalar_one_or_none()
            return self._model_to_entity(model) if model else None
        except Exception as e:
            logger.error(f"Error finding latest rate for {currency_pair.to_string()}: {str(e)}")
            raise

    def _model_to_entity(self, model: ExchangeRateModel) -> ExchangeRate:
        """モデルからエンティティへ変換"""
        return ExchangeRate(
            id=model.id,
            uuid=model.uuid,
            currency_pair=model.currency_pair,
            timestamp=model.timestamp,
            open_price=model.open_price,
            high_price=model.high_price,
            low_price=model.low_price,
            close_price=model.close_price,
            volume=model.volume,
            source=model.source,
            created_at=model.created_at,
            updated_at=model.updated_at,
            version=model.version
        )

    def _entity_to_model(self, entity: ExchangeRate) -> ExchangeRateModel:
        """エンティティからモデルへ変換"""
        return ExchangeRateModel(
            id=entity.id,
            uuid=entity.uuid,
            currency_pair=entity.currency_pair,
            timestamp=entity.timestamp,
            open_price=entity.open_price,
            high_price=entity.high_price,
            low_price=entity.low_price,
            close_price=entity.close_price,
            volume=entity.volume,
            source=entity.source,
            created_at=entity.created_at,
            updated_at=entity.updated_at,
            version=entity.version
        )

    def _entity_to_dict(self, entity: ExchangeRate) -> dict:
        """エンティティから辞書へ変換"""
        return {
            'currency_pair': entity.currency_pair,
            'timestamp': entity.timestamp,
            'open_price': entity.open_price,
            'high_price': entity.high_price,
            'low_price': entity.low_price,
            'close_price': entity.close_price,
            'volume': entity.volume,
            'source': entity.source,
            'updated_at': entity.updated_at,
            'version': entity.version
        }
```

## 3. External APIs Implementation

### 3.1 Base API Client

#### src/infrastructure/external_apis/base_api_client.py

```python
"""外部API基底クライアント"""
import asyncio
import aiohttp
from typing import Dict, Any, Optional, List
from datetime import datetime, timedelta
import json
import logging
from ...shared.exceptions import ExternalAPIException

logger = logging.getLogger(__name__)

class BaseAPIClient:
    """外部API基底クライアント"""

    def __init__(
        self,
        base_url: str,
        api_key: Optional[str] = None,
        timeout: int = 30,
        retry_count: int = 3,
        retry_delay: float = 1.0
    ):
        self.base_url = base_url.rstrip('/')
        self.api_key = api_key
        self.timeout = aiohttp.ClientTimeout(total=timeout)
        self.retry_count = retry_count
        self.retry_delay = retry_delay
        self._session: Optional[aiohttp.ClientSession] = None

        # レート制限管理
        self._last_request_time = None
        self._min_request_interval = 0.2  # 200ms間隔

    async def __aenter__(self):
        await self._ensure_session()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.close()

    async def _ensure_session(self):
        """セッション確保"""
        if self._session is None or self._session.closed:
            headers = self._get_default_headers()
            self._session = aiohttp.ClientSession(
                headers=headers,
                timeout=self.timeout
            )

    async def close(self):
        """セッションクローズ"""
        if self._session and not self._session.closed:
            await self._session.close()
            self._session = None

    def _get_default_headers(self) -> Dict[str, str]:
        """デフォルトヘッダー取得"""
        headers = {
            'User-Agent': 'ExchangeAnalyticsApp/1.0',
            'Accept': 'application/json',
            'Content-Type': 'application/json'
        }

        if self.api_key:
            headers['Authorization'] = f'Bearer {self.api_key}'

        return headers

    async def _rate_limit_wait(self):
        """レート制限待機"""
        if self._last_request_time:
            elapsed = datetime.now().timestamp() - self._last_request_time
            if elapsed < self._min_request_interval:
                wait_time = self._min_request_interval - elapsed
                await asyncio.sleep(wait_time)

        self._last_request_time = datetime.now().timestamp()

    async def _make_request(
        self,
        method: str,
        endpoint: str,
        params: Optional[Dict[str, Any]] = None,
        data: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None
    ) -> Dict[str, Any]:
        """HTTP リクエスト実行"""
        await self._ensure_session()
        await self._rate_limit_wait()

        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        request_headers = headers or {}

        for attempt in range(self.retry_count):
            try:
                async with self._session.request(
                    method=method,
                    url=url,
                    params=params,
                    json=data,
                    headers=request_headers
                ) as response:

                    logger.debug(f"API Request: {method} {url} - Status: {response.status}")

                    if response.status == 429:  # Too Many Requests
                        retry_after = int(response.headers.get('Retry-After', 60))
                        logger.warning(f"Rate limited, waiting {retry_after} seconds")
                        await asyncio.sleep(retry_after)
                        continue

                    response.raise_for_status()

                    content_type = response.headers.get('Content-Type', '')
                    if 'application/json' in content_type:
                        return await response.json()
                    else:
                        text = await response.text()
                        return {'data': text}

            except aiohttp.ClientError as e:
                logger.error(f"API request failed (attempt {attempt + 1}): {str(e)}")
                if attempt == self.retry_count - 1:
                    raise ExternalAPIException(f"API request failed after {self.retry_count} attempts: {str(e)}")

                await asyncio.sleep(self.retry_delay * (2 ** attempt))  # 指数バックオフ

        raise ExternalAPIException("Max retry attempts reached")

    async def get(
        self,
        endpoint: str,
        params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None
    ) -> Dict[str, Any]:
        """GET リクエスト"""
        return await self._make_request('GET', endpoint, params=params, headers=headers)

    async def post(
        self,
        endpoint: str,
        data: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None
    ) -> Dict[str, Any]:
        """POST リクエスト"""
        return await self._make_request('POST', endpoint, data=data, headers=headers)

    async def health_check(self) -> Dict[str, Any]:
        """ヘルスチェック（サブクラスで実装）"""
        raise NotImplementedError("Subclasses must implement health_check")
```

### 3.2 Alpha Vantage Client

#### src/infrastructure/external_apis/alpha_vantage_client.py

```python
"""Alpha Vantage API クライアント"""
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
from ...application.interfaces.data_fetcher_interface import DataFetcherInterface
from ...domain.value_objects.currency_pair import CurrencyPair
from .base_api_client import BaseAPIClient
from ...shared.exceptions import ExternalAPIException
import logging

logger = logging.getLogger(__name__)

class AlphaVantageClient(BaseAPIClient, DataFetcherInterface):
    """Alpha Vantage API クライアント"""

    def __init__(self, api_key: str):
        super().__init__(
            base_url="https://www.alphavantage.co/query",
            api_key=api_key,
            timeout=60,
            retry_count=3
        )
        self._min_request_interval = 12.0  # 無料版は5回/分なので12秒間隔

    def _get_default_headers(self) -> Dict[str, str]:
        """Alpha VantageはヘッダーではなくパラメータでAPIキーを送信"""
        return {
            'User-Agent': 'ExchangeAnalyticsApp/1.0',
            'Accept': 'application/json'
        }

    async def fetch_exchange_rates(
        self,
        currency_pair: CurrencyPair,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None,
        interval: str = "1m"
    ) -> List[Dict[str, Any]]:
        """為替レート取得"""
        try:
            # Alpha Vantageの関数マッピング
            function_map = {
                "1m": "FX_INTRADAY",
                "5m": "FX_INTRADAY",
                "15m": "FX_INTRADAY",
                "30m": "FX_INTRADAY",
                "1h": "FX_INTRADAY",
                "1d": "FX_DAILY"
            }

            function = function_map.get(interval, "FX_INTRADAY")

            params = {
                'function': function,
                'from_symbol': currency_pair.base_currency,
                'to_symbol': currency_pair.quote_currency,
                'apikey': self.api_key,
                'outputsize': 'full',
                'datatype': 'json'
            }

            if function == "FX_INTRADAY":
                params['interval'] = interval

            response = await self.get('', params=params)

            # レスポンス解析
            return self._parse_fx_response(response, interval)

        except Exception as e:
            logger.error(f"Error fetching rates from Alpha Vantage: {str(e)}")
            raise ExternalAPIException(f"Alpha Vantage API error: {str(e)}")

    async def fetch_latest_rate(
        self,
        currency_pair: CurrencyPair
    ) -> Optional[Dict[str, Any]]:
        """最新レート取得"""
        try:
            params = {
                'function': 'CURRENCY_EXCHANGE_RATE',
                'from_currency': currency_pair.base_currency,
                'to_currency': currency_pair.quote_currency,
                'apikey': self.api_key
            }

            response = await self.get('', params=params)

            # レスポンス解析
            if 'Realtime Currency Exchange Rate' in response:
                rate_data = response['Realtime Currency Exchange Rate']
                return {
                    'currency_pair': currency_pair.to_string_no_slash(),
                    'timestamp': datetime.fromisoformat(rate_data['6. Last Refreshed'].replace(' ', 'T')),
                    'open': float(rate_data['2. From_Currency Name']),  # Alpha Vantageの構造に合わせて調整
                    'high': float(rate_data['3. To_Currency Name']),
                    'low': float(rate_data['4. Exchange Rate']),
                    'close': float(rate_data['5. Exchange Rate']),
                    'volume': None
                }

            return None

        except Exception as e:
            logger.error(f"Error fetching latest rate from Alpha Vantage: {str(e)}")
            raise ExternalAPIException(f"Alpha Vantage API error: {str(e)}")

    def _parse_fx_response(self, response: Dict[str, Any], interval: str) -> List[Dict[str, Any]]:
        """FXレスポンス解析"""
        rates = []

        # データキーの特定
        if interval == "1d":
            time_series_key = "Time Series FX (Daily)"
        else:
            time_series_key = f"Time Series FX ({interval})"

        if time_series_key not in response:
            logger.warning(f"No time series data found in response: {list(response.keys())}")
            return rates

        time_series = response[time_series_key]

        for timestamp_str, ohlc_data in time_series.items():
            try:
                timestamp = datetime.fromisoformat(timestamp_str.replace(' ', 'T'))

                rate = {
                    'timestamp': timestamp,
                    'open': float(ohlc_data['1. open']),
                    'high': float(ohlc_data['2. high']),
                    'low': float(ohlc_data['3. low']),
                    'close': float(ohlc_data['4. close']),
                    'volume': None  # FXデータには通常ボリュームなし
                }

                rates.append(rate)

            except (ValueError, KeyError) as e:
                logger.warning(f"Error parsing OHLC data for {timestamp_str}: {str(e)}")
                continue

        # 時系列順にソート
        rates.sort(key=lambda x: x['timestamp'])

        return rates

    async def get_supported_pairs(self) -> List[CurrencyPair]:
        """サポートされている通貨ペア取得"""
        # Alpha Vantageは主要通貨ペアをサポート
        major_pairs = [
            "EURUSD", "GBPUSD", "USDJPY", "USDCHF",
            "AUDUSD", "USDCAD", "NZDUSD",
            "EURJPY", "GBPJPY", "AUDJPY"
        ]

        pairs = []
        for pair_str in major_pairs:
            try:
                pair = CurrencyPair.from_string(pair_str)
                pairs.append(pair)
            except ValueError:
                continue

        return pairs

    async def check_api_status(self) -> Dict[str, Any]:
        """API状態チェック"""
        try:
            # シンプルなテストクエリ
            test_pair = CurrencyPair("USD", "JPY")
            result = await self.fetch_latest_rate(test_pair)

            return {
                'status': 'healthy' if result else 'degraded',
                'service': 'alpha_vantage',
                'timestamp': datetime.utcnow().isoformat(),
                'response_time': None  # 実装可能だが簡略化
            }

        except Exception as e:
            return {
                'status': 'unhealthy',
                'service': 'alpha_vantage',
                'timestamp': datetime.utcnow().isoformat(),
                'error': str(e)
            }

    async def get_rate_limits(self) -> Dict[str, Any]:
        """レート制限情報取得"""
        return {
            'requests_per_minute': 5,
            'requests_per_day': 500,
            'current_interval': self._min_request_interval,
            'description': 'Alpha Vantage Free Tier Limits'
        }

    async def health_check(self) -> Dict[str, Any]:
        """ヘルスチェック"""
        return await self.check_api_status()
```

## 4. Plugin System

### 4.1 Plugin Registry & Loader

#### plugins/registry.py

```python
"""プラグイン登録・管理システム"""
import asyncio
import importlib
import inspect
from typing import Dict, List, Type, Any, Optional
from pathlib import Path
import yaml
import json
from .interfaces.base_plugin import BasePlugin
from .interfaces.technical_indicator_plugin import TechnicalIndicatorPlugin
from .interfaces.analysis_plugin import AnalysisPlugin
from .interfaces.report_plugin import ReportPlugin
import logging

logger = logging.getLogger(__name__)

class PluginRegistry:
    """プラグイン登録・管理クラス"""

    def __init__(self):
        self._plugins: Dict[str, Type[BasePlugin]] = {}
        self._instances: Dict[str, BasePlugin] = {}
        self._plugin_configs: Dict[str, Dict[str, Any]] = {}
        self._enabled_plugins: Dict[str, bool] = {}

        # プラグインタイプ別管理
        self._technical_plugins: Dict[str, TechnicalIndicatorPlugin] = {}
        self._analysis_plugins: Dict[str, AnalysisPlugin] = {}
        self._report_plugins: Dict[str, ReportPlugin] = {}

    def register_plugin(
        self,
        plugin_class: Type[BasePlugin],
        config: Optional[Dict[str, Any]] = None
    ):
        """プラグイン登録"""
        plugin_name = plugin_class.__name__

        # 基底クラスチェック
        if not issubclass(plugin_class, BasePlugin):
            raise ValueError(f"Plugin {plugin_name} must inherit from BasePlugin")

        # 重複チェック
        if plugin_name in self._plugins:
            logger.warning(f"Plugin {plugin_name} is already registered, overwriting")

        self._plugins[plugin_name] = plugin_class
        self._plugin_configs[plugin_name] = config or {}
        self._enabled_plugins[plugin_name] = True

        logger.info(f"Registered plugin: {plugin_name}")

    def get_plugin_instance(
        self,
        plugin_name: str,
        force_reload: bool = False
    ) -> Optional[BasePlugin]:
        """プラグインインスタンス取得"""
        if plugin_name not in self._plugins:
            logger.error(f"Plugin {plugin_name} not found")
            return None

        if not self._enabled_plugins.get(plugin_name, False):
            logger.warning(f"Plugin {plugin_name} is disabled")
            return None

        # インスタンス取得または作成
        if force_reload or plugin_name not in self._instances:
            plugin_class = self._plugins[plugin_name]
            config = self._plugin_configs.get(plugin_name, {})

            try:
                instance = plugin_class(
                    name=plugin_name,
                    version="1.0.0",  # バージョン管理の実装可能
                    config=config
                )

                # 初期化
                if hasattr(instance, 'initialize'):
                    if inspect.iscoroutinefunction(instance.initialize):
                        asyncio.create_task(instance.initialize())
                    else:
                        instance.initialize()

                self._instances[plugin_name] = instance

                # タイプ別登録
                self._register_by_type(instance)

                logger.info(f"Created instance for plugin: {plugin_name}")

            except Exception as e:
                logger.error(f"Failed to create instance for {plugin_name}: {str(e)}")
                return None

        return self._instances[plugin_name]

    def _register_by_type(self, instance: BasePlugin):
        """タイプ別プラグイン登録"""
        if isinstance(instance, TechnicalIndicatorPlugin):
            self._technical_plugins[instance.name] = instance
        elif isinstance(instance, AnalysisPlugin):
            self._analysis_plugins[instance.name] = instance
        elif isinstance(instance, ReportPlugin):
            self._report_plugins[instance.name] = instance

    def get_technical_plugins(self) -> Dict[str, TechnicalIndicatorPlugin]:
        """テクニカル指標プラグイン取得"""
        return {
            name: plugin for name, plugin in self._technical_plugins.items()
            if self._enabled_plugins.get(name, False)
        }

    def get_analysis_plugins(self) -> Dict[str, AnalysisPlugin]:
        """分析プラグイン取得"""
        return {
            name: plugin for name, plugin in self._analysis_plugins.items()
            if self._enabled_plugins.get(name, False)
        }

    def get_report_plugins(self) -> Dict[str, ReportPlugin]:
        """レポートプラグイン取得"""
        return {
            name: plugin for name, plugin in self._report_plugins.items()
            if self._enabled_plugins.get(name, False)
        }

    def enable_plugin(self, plugin_name: str):
        """プラグイン有効化"""
        if plugin_name in self._plugins:
            self._enabled_plugins[plugin_name] = True
            logger.info(f"Enabled plugin: {plugin_name}")
        else:
            logger.error(f"Plugin {plugin_name} not found")

    def disable_plugin(self, plugin_name: str):
        """プラグイン無効化"""
        if plugin_name in self._plugins:
            self._enabled_plugins[plugin_name] = False
            # インスタンスも削除
            if plugin_name in self._instances:
                del self._instances[plugin_name]
            logger.info(f"Disabled plugin: {plugin_name}")
        else:
            logger.error(f"Plugin {plugin_name} not found")

    def update_plugin_config(
        self,
        plugin_name: str,
        new_config: Dict[str, Any]
    ):
        """プラグイン設定更新"""
        if plugin_name not in self._plugins:
            logger.error(f"Plugin {plugin_name} not found")
            return

        self._plugin_configs[plugin_name].update(new_config)

        # インスタンスが存在する場合は再作成
        if plugin_name in self._instances:
            self.get_plugin_instance(plugin_name, force_reload=True)

        logger.info(f"Updated config for plugin: {plugin_name}")

    def list_plugins(self) -> List[Dict[str, Any]]:
        """プラグイン一覧取得"""
        plugins_info = []

        for name, plugin_class in self._plugins.items():
            plugins_info.append({
                'name': name,
                'class': plugin_class.__name__,
                'enabled': self._enabled_plugins.get(name, False),
                'has_instance': name in self._instances,
                'config': self._plugin_configs.get(name, {}),
                'type': self._get_plugin_type(plugin_class)
            })

        return plugins_info

    def _get_plugin_type(self, plugin_class: Type[BasePlugin]) -> str:
        """プラグインタイプ判定"""
        if issubclass(plugin_class, TechnicalIndicatorPlugin):
            return "technical"
        elif issubclass(plugin_class, AnalysisPlugin):
            return "analysis"
        elif issubclass(plugin_class, ReportPlugin):
            return "report"
        else:
            return "base"

    async def load_plugins_from_directory(self, plugin_dir: Path):
        """ディレクトリからプラグイン読み込み"""
        if not plugin_dir.exists():
            logger.warning(f"Plugin directory does not exist: {plugin_dir}")
            return

        for plugin_path in plugin_dir.rglob("plugin.py"):
            try:
                await self._load_plugin_from_file(plugin_path)
            except Exception as e:
                logger.error(f"Failed to load plugin from {plugin_path}: {str(e)}")

    async def _load_plugin_from_file(self, plugin_file: Path):
        """ファイルからプラグイン読み込み"""
        # モジュール動的インポート
        spec = importlib.util.spec_from_file_location(
            f"plugin_{plugin_file.parent.name}",
            plugin_file
        )
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

        # プラグインクラス検索
        for name, obj in inspect.getmembers(module, inspect.isclass):
            if (issubclass(obj, BasePlugin) and
                obj != BasePlugin and
                obj.__module__ == module.__name__):

                # 設定ファイル読み込み
                config_file = plugin_file.parent / "config.json"
                config = {}
                if config_file.exists():
                    with open(config_file, 'r') as f:
                        config = json.load(f)

                self.register_plugin(obj, config)
                break

    def get_plugin_status(self) -> Dict[str, Any]:
        """プラグイン状態取得"""
        return {
            'total_plugins': len(self._plugins),
            'enabled_plugins': sum(self._enabled_plugins.values()),
            'active_instances': len(self._instances),
            'technical_plugins': len(self._technical_plugins),
            'analysis_plugins': len(self._analysis_plugins),
            'report_plugins': len(self._report_plugins)
        }
```

この詳細設計により、各層の責任が明確に分離され、モジュール間の依存関係が適切に管理されます。また、プラグインシステムにより将来的な機能拡張が容易になります。

次に Presentation Layer (API・Web) の設計を作成しますか？
