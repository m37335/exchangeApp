# Application Layer 詳細設計

**作成日**: 2025 年 8 月 9 日
**対象**: アプリケーション層（ユースケース）の詳細設計
**依存関係**: Domain Layer のインターフェースに依存

## 1. Application Layer 構成

```
src/application/
├── commands/           # コマンド（書き込み操作）
├── queries/           # クエリ（読み込み操作）
├── handlers/          # ハンドラー（ユースケース実装）
├── interfaces/        # 外部サービスインターフェース
├── dto/              # データ転送オブジェクト
└── exceptions/       # アプリケーション固有例外
```

## 2. Commands (コマンド)

### 2.1 Base Command

#### src/application/commands/base.py

```python
"""ベースコマンドクラス"""
from abc import ABC
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, Dict, Any
import uuid

@dataclass
class BaseCommand(ABC):
    """全コマンドの基底クラス"""
    command_id: str = None
    timestamp: datetime = None
    user_id: Optional[str] = None
    correlation_id: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None

    def __post_init__(self):
        if self.command_id is None:
            self.command_id = str(uuid.uuid4())
        if self.timestamp is None:
            self.timestamp = datetime.utcnow()
        if self.metadata is None:
            self.metadata = {}

    def add_metadata(self, key: str, value: Any):
        """メタデータ追加"""
        self.metadata[key] = value

    def to_dict(self) -> Dict[str, Any]:
        """辞書変換"""
        return {
            'command_id': self.command_id,
            'command_type': self.__class__.__name__,
            'timestamp': self.timestamp.isoformat(),
            'user_id': self.user_id,
            'correlation_id': self.correlation_id,
            'metadata': self.metadata
        }
```

#### src/application/commands/generate_report_command.py

```python
"""AI分析レポート生成コマンド"""
from dataclasses import dataclass
from datetime import date
from typing import List, Optional
from ..entities.analysis_report import ReportType
from .base import BaseCommand

@dataclass
class GenerateReportCommand(BaseCommand):
    """AI分析レポート生成コマンド"""
    report_date: date
    report_type: ReportType
    currency_pairs: List[str]
    custom_prompt: Optional[str] = None
    force_regenerate: bool = False

    def __post_init__(self):
        super().__post_init__()
        self._validate()

    def _validate(self):
        """バリデーション"""
        if not self.currency_pairs:
            raise ValueError("Currency pairs are required")

        if len(self.currency_pairs) > 10:
            raise ValueError("Too many currency pairs (max: 10)")

        for pair in self.currency_pairs:
            if len(pair) != 6:
                raise ValueError(f"Invalid currency pair format: {pair}")

        if self.custom_prompt and len(self.custom_prompt) > 5000:
            raise ValueError("Custom prompt too long (max: 5000 characters)")

    def to_dict(self) -> dict:
        """辞書変換"""
        base_dict = super().to_dict()
        base_dict.update({
            'report_date': self.report_date.isoformat(),
            'report_type': self.report_type.value,
            'currency_pairs': self.currency_pairs,
            'custom_prompt': self.custom_prompt,
            'force_regenerate': self.force_regenerate
        })
        return base_dict
```

#### src/application/commands/fetch_rates_command.py

```python
"""為替レート取得コマンド"""
from dataclasses import dataclass
from datetime import datetime
from typing import List, Optional
from .base import BaseCommand

@dataclass
class FetchRatesCommand(BaseCommand):
    """為替レート取得コマンド"""
    currency_pairs: List[str]
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    interval: str = "1m"  # 1m, 5m, 15m, 1h, 1d
    source: str = "alpha_vantage"

    def __post_init__(self):
        super().__post_init__()
        self._validate()

    def _validate(self):
        """バリデーション"""
        if not self.currency_pairs:
            raise ValueError("Currency pairs are required")

        valid_intervals = ["1m", "5m", "15m", "30m", "1h", "4h", "1d"]
        if self.interval not in valid_intervals:
            raise ValueError(f"Invalid interval: {self.interval}")

        if self.start_time and self.end_time:
            if self.start_time >= self.end_time:
                raise ValueError("Start time must be before end time")

        valid_sources = ["alpha_vantage", "yahoo_finance", "mock"]
        if self.source not in valid_sources:
            raise ValueError(f"Invalid source: {self.source}")

    def get_lookback_hours(self) -> int:
        """デフォルトの取得期間（時間）"""
        if self.start_time and self.end_time:
            return int((self.end_time - self.start_time).total_seconds() / 3600)

        # インターバル別デフォルト期間
        default_periods = {
            "1m": 24,    # 1日分
            "5m": 120,   # 5日分
            "15m": 360,  # 15日分
            "30m": 720,  # 30日分
            "1h": 720,   # 30日分
            "4h": 2880,  # 120日分
            "1d": 8760   # 365日分
        }
        return default_periods.get(self.interval, 24)
```

### 2.2 Alert Commands

#### src/application/commands/create_alert_command.py

```python
"""アラート作成コマンド"""
from dataclasses import dataclass
from decimal import Decimal
from typing import Dict, Any, Optional
from enum import Enum
from .base import BaseCommand

class AlertType(Enum):
    """アラートタイプ"""
    PRICE_ABOVE = "price_above"
    PRICE_BELOW = "price_below"
    PRICE_CHANGE = "price_change"
    TECHNICAL_SIGNAL = "technical_signal"
    AI_RECOMMENDATION = "ai_recommendation"

@dataclass
class CreateAlertCommand(BaseCommand):
    """アラート作成コマンド"""
    currency_pair: str
    alert_type: AlertType
    condition_data: Dict[str, Any]
    notification_channels: List[str]  # ["discord", "email"]
    is_active: bool = True
    description: Optional[str] = None

    def __post_init__(self):
        super().__post_init__()
        self._validate()

    def _validate(self):
        """バリデーション"""
        if not self.currency_pair or len(self.currency_pair) != 6:
            raise ValueError("Invalid currency pair")

        if not self.condition_data:
            raise ValueError("Condition data is required")

        if not self.notification_channels:
            raise ValueError("At least one notification channel is required")

        valid_channels = ["discord", "email", "webhook"]
        for channel in self.notification_channels:
            if channel not in valid_channels:
                raise ValueError(f"Invalid notification channel: {channel}")

        # アラートタイプ別バリデーション
        self._validate_condition_data()

    def _validate_condition_data(self):
        """条件データバリデーション"""
        if self.alert_type in [AlertType.PRICE_ABOVE, AlertType.PRICE_BELOW]:
            if "threshold_price" not in self.condition_data:
                raise ValueError("threshold_price is required for price alerts")

            try:
                Decimal(str(self.condition_data["threshold_price"]))
            except:
                raise ValueError("threshold_price must be a valid number")

        elif self.alert_type == AlertType.PRICE_CHANGE:
            if "percentage_change" not in self.condition_data:
                raise ValueError("percentage_change is required for price change alerts")

            try:
                percentage = float(self.condition_data["percentage_change"])
                if percentage <= 0:
                    raise ValueError("percentage_change must be positive")
            except:
                raise ValueError("percentage_change must be a valid positive number")

        elif self.alert_type == AlertType.TECHNICAL_SIGNAL:
            required_fields = ["indicator_type", "signal_condition"]
            for field in required_fields:
                if field not in self.condition_data:
                    raise ValueError(f"{field} is required for technical signal alerts")
```

## 3. Queries (クエリ)

### 3.1 Base Query

#### src/application/queries/base.py

```python
"""ベースクエリクラス"""
from abc import ABC
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, Dict, Any
import uuid

@dataclass
class BaseQuery(ABC):
    """全クエリの基底クラス"""
    query_id: str = None
    timestamp: datetime = None
    user_id: Optional[str] = None
    limit: int = 100
    offset: int = 0

    def __post_init__(self):
        if self.query_id is None:
            self.query_id = str(uuid.uuid4())
        if self.timestamp is None:
            self.timestamp = datetime.utcnow()

        # 制限値の検証
        if self.limit <= 0 or self.limit > 1000:
            raise ValueError("Limit must be between 1 and 1000")

        if self.offset < 0:
            raise ValueError("Offset must be non-negative")
```

#### src/application/queries/get_rates_query.py

```python
"""為替レート取得クエリ"""
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, List
from .base import BaseQuery

@dataclass
class GetRatesQuery(BaseQuery):
    """為替レート取得クエリ"""
    currency_pairs: Optional[List[str]] = None
    start_date: Optional[datetime] = None
    end_date: Optional[datetime] = None
    interval: Optional[str] = None
    include_volume: bool = True

    def __post_init__(self):
        super().__post_init__()
        self._validate()

    def _validate(self):
        """バリデーション"""
        if self.currency_pairs:
            for pair in self.currency_pairs:
                if len(pair) != 6:
                    raise ValueError(f"Invalid currency pair: {pair}")

        if self.start_date and self.end_date:
            if self.start_date >= self.end_date:
                raise ValueError("Start date must be before end date")

        if self.interval:
            valid_intervals = ["1m", "5m", "15m", "30m", "1h", "4h", "1d"]
            if self.interval not in valid_intervals:
                raise ValueError(f"Invalid interval: {self.interval}")
```

#### src/application/queries/get_analysis_query.py

```python
"""分析データ取得クエリ"""
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, List
from .base import BaseQuery

@dataclass
class GetAnalysisQuery(BaseQuery):
    """分析データ取得クエリ"""
    currency_pair: str
    analysis_types: List[str]  # ["technical", "ai", "signals"]
    start_date: Optional[datetime] = None
    end_date: Optional[datetime] = None
    include_confidence: bool = True
    include_metadata: bool = False

    def __post_init__(self):
        super().__post_init__()
        self._validate()

    def _validate(self):
        """バリデーション"""
        if not self.currency_pair or len(self.currency_pair) != 6:
            raise ValueError("Invalid currency pair")

        if not self.analysis_types:
            raise ValueError("Analysis types are required")

        valid_types = ["technical", "ai", "signals", "support_resistance", "trends"]
        for analysis_type in self.analysis_types:
            if analysis_type not in valid_types:
                raise ValueError(f"Invalid analysis type: {analysis_type}")
```

## 4. Handlers (ハンドラー)

### 4.1 Command Handlers

#### src/application/handlers/report_handler.py

```python
"""レポート関連ハンドラー"""
import asyncio
from typing import Dict, Any
from ..commands.generate_report_command import GenerateReportCommand
from ..interfaces.ai_analyzer_interface import AIAnalyzerInterface
from ..interfaces.data_fetcher_interface import DataFetcherInterface
from ..interfaces.notifier_interface import NotifierInterface
from ...domain.repositories.analysis_report_repository import AnalysisReportRepository
from ...domain.repositories.exchange_rate_repository import ExchangeRateRepository
from ...domain.entities.analysis_report import AnalysisReport, ReportStatus
from ...shared.exceptions import ApplicationException
import logging

logger = logging.getLogger(__name__)

class ReportHandler:
    """レポート関連のユースケース処理"""

    def __init__(
        self,
        ai_analyzer: AIAnalyzerInterface,
        data_fetcher: DataFetcherInterface,
        notifier: NotifierInterface,
        report_repository: AnalysisReportRepository,
        rate_repository: ExchangeRateRepository
    ):
        self.ai_analyzer = ai_analyzer
        self.data_fetcher = data_fetcher
        self.notifier = notifier
        self.report_repository = report_repository
        self.rate_repository = rate_repository

    async def handle_generate_report(
        self,
        command: GenerateReportCommand
    ) -> AnalysisReport:
        """AI分析レポート生成処理"""
        try:
            logger.info(f"Starting report generation: {command.command_id}")

            # 1. 既存レポートチェック
            if not command.force_regenerate:
                existing_report = await self.report_repository.find_latest_by_type(
                    command.report_type
                )
                if (existing_report and
                    existing_report.report_date == command.report_date):
                    logger.info(f"Report already exists: {existing_report.id}")
                    return existing_report

            # 2. 市場データ取得
            market_data = await self._fetch_market_data(command.currency_pairs)

            # 3. テクニカル分析データ取得
            technical_data = await self._fetch_technical_data(command.currency_pairs)

            # 4. AI分析実行
            ai_analysis = await self.ai_analyzer.generate_market_analysis(
                market_data=market_data,
                technical_data=technical_data,
                currency_pairs=command.currency_pairs,
                custom_prompt=command.custom_prompt
            )

            # 5. レポートエンティティ作成
            report = AnalysisReport(
                report_date=command.report_date,
                report_type=command.report_type,
                status=ReportStatus.GENERATED,
                title=ai_analysis["title"],
                market_summary=ai_analysis["market_summary"],
                technical_analysis=ai_analysis["technical_analysis"],
                fundamental_analysis=ai_analysis.get("fundamental_analysis"),
                recommendations=ai_analysis.get("recommendations"),
                currency_pairs_analyzed=command.currency_pairs,
                confidence_score=ai_analysis.get("confidence_score"),
                ai_model_used=ai_analysis.get("model", "gpt-4"),
                generation_time_seconds=ai_analysis.get("generation_time")
            )

            # 6. レポート保存
            saved_report = await self.report_repository.save(report)

            # 7. 通知送信（非同期）
            asyncio.create_task(
                self._send_report_notification(saved_report)
            )

            logger.info(f"Report generated successfully: {saved_report.id}")
            return saved_report

        except Exception as e:
            logger.error(f"Report generation failed: {str(e)}")
            # エラーレポート作成
            error_report = AnalysisReport(
                report_date=command.report_date,
                report_type=command.report_type,
                status=ReportStatus.FAILED,
                title="Report Generation Failed",
                market_summary="Report generation encountered an error",
                technical_analysis="Error occurred during analysis",
                error_message=str(e)
            )
            await self.report_repository.save(error_report)
            raise ApplicationException(f"Report generation failed: {str(e)}")

    async def _fetch_market_data(self, currency_pairs: List[str]) -> Dict[str, Any]:
        """市場データ取得"""
        market_data = {}

        for pair in currency_pairs:
            try:
                # 最新レートとOHLCデータ取得
                latest_rates = await self.rate_repository.find_by_currency_pair_and_date_range(
                    currency_pair=CurrencyPair.from_string(pair),
                    start_date=datetime.utcnow() - timedelta(days=1),
                    end_date=datetime.utcnow()
                )

                if latest_rates:
                    market_data[pair] = {
                        "latest_rate": latest_rates[-1],
                        "historical_rates": latest_rates,
                        "volatility": self._calculate_volatility(latest_rates)
                    }

            except Exception as e:
                logger.warning(f"Failed to fetch data for {pair}: {str(e)}")
                continue

        return market_data

    async def _fetch_technical_data(self, currency_pairs: List[str]) -> Dict[str, Any]:
        """テクニカル分析データ取得"""
        # プラグインマネージャーから技術指標を取得
        # この部分は Plugin System の実装後に詳細化
        return {}

    async def _send_report_notification(self, report: AnalysisReport):
        """レポート通知送信"""
        try:
            if report.is_suitable_for_discord():
                message_id = await self.notifier.send_discord_report(report)
                report.mark_as_sent(message_id)
                await self.report_repository.update(report)
            else:
                logger.warning(f"Report {report.id} too long for Discord")

        except Exception as e:
            logger.error(f"Failed to send notification for report {report.id}: {str(e)}")
            report.mark_as_failed(str(e))
            await self.report_repository.update(report)

    def _calculate_volatility(self, rates: List[ExchangeRate]) -> float:
        """簡易ボラティリティ計算"""
        if len(rates) < 2:
            return 0.0

        returns = []
        for i in range(1, len(rates)):
            current = float(rates[i].close_price)
            previous = float(rates[i-1].close_price)
            returns.append(abs(current - previous) / previous)

        return sum(returns) / len(returns) if returns else 0.0
```

#### src/application/handlers/data_handler.py

```python
"""データ取得関連ハンドラー"""
from typing import List, Dict, Any
from datetime import datetime, timedelta
from ..commands.fetch_rates_command import FetchRatesCommand
from ..queries.get_rates_query import GetRatesQuery
from ..interfaces.data_fetcher_interface import DataFetcherInterface
from ...domain.repositories.exchange_rate_repository import ExchangeRateRepository
from ...domain.entities.exchange_rate import ExchangeRate
from ...domain.value_objects.currency_pair import CurrencyPair
from ...shared.exceptions import ApplicationException
import logging

logger = logging.getLogger(__name__)

class DataHandler:
    """データ取得関連のユースケース処理"""

    def __init__(
        self,
        data_fetcher: DataFetcherInterface,
        rate_repository: ExchangeRateRepository
    ):
        self.data_fetcher = data_fetcher
        self.rate_repository = rate_repository

    async def handle_fetch_rates(
        self,
        command: FetchRatesCommand
    ) -> List[ExchangeRate]:
        """為替レート取得処理"""
        try:
            logger.info(f"Fetching rates for: {command.currency_pairs}")

            fetched_rates = []

            for pair_str in command.currency_pairs:
                currency_pair = CurrencyPair.from_string(pair_str)

                # 外部APIからデータ取得
                rates_data = await self.data_fetcher.fetch_exchange_rates(
                    currency_pair=currency_pair,
                    start_time=command.start_time,
                    end_time=command.end_time,
                    interval=command.interval
                )

                # エンティティ変換
                rates = [
                    ExchangeRate(
                        currency_pair=pair_str,
                        timestamp=rate_data["timestamp"],
                        open_price=rate_data["open"],
                        high_price=rate_data["high"],
                        low_price=rate_data["low"],
                        close_price=rate_data["close"],
                        volume=rate_data.get("volume"),
                        source=command.source
                    )
                    for rate_data in rates_data
                ]

                # 一括保存
                saved_rates = await self.rate_repository.bulk_save(rates)
                fetched_rates.extend(saved_rates)

                logger.info(f"Saved {len(saved_rates)} rates for {pair_str}")

            return fetched_rates

        except Exception as e:
            logger.error(f"Failed to fetch rates: {str(e)}")
            raise ApplicationException(f"Rate fetching failed: {str(e)}")

    async def handle_get_rates(
        self,
        query: GetRatesQuery
    ) -> List[ExchangeRate]:
        """為替レート検索処理"""
        try:
            if query.currency_pairs:
                # 特定通貨ペアの検索
                all_rates = []
                for pair_str in query.currency_pairs:
                    currency_pair = CurrencyPair.from_string(pair_str)

                    if query.start_date and query.end_date:
                        rates = await self.rate_repository.find_by_currency_pair_and_date_range(
                            currency_pair=currency_pair,
                            start_date=query.start_date,
                            end_date=query.end_date
                        )
                    else:
                        rates = await self.rate_repository.find_by_currency_pair(
                            currency_pair=currency_pair,
                            limit=query.limit
                        )

                    all_rates.extend(rates)

                return all_rates
            else:
                # 全通貨ペアの検索
                return await self.rate_repository.find_all(
                    limit=query.limit,
                    offset=query.offset
                )

        except Exception as e:
            logger.error(f"Failed to get rates: {str(e)}")
            raise ApplicationException(f"Rate query failed: {str(e)}")

    async def handle_get_latest_rates(
        self,
        currency_pairs: List[str]
    ) -> Dict[str, ExchangeRate]:
        """最新レート取得処理"""
        try:
            latest_rates = {}

            for pair_str in currency_pairs:
                currency_pair = CurrencyPair.from_string(pair_str)
                rate = await self.rate_repository.find_latest_by_currency_pair(
                    currency_pair
                )

                if rate:
                    latest_rates[pair_str] = rate
                else:
                    logger.warning(f"No rate found for {pair_str}")

            return latest_rates

        except Exception as e:
            logger.error(f"Failed to get latest rates: {str(e)}")
            raise ApplicationException(f"Latest rate query failed: {str(e)}")
```

## 5. Interfaces (外部サービスインターフェース)

### 5.1 Data Fetcher Interface

#### src/application/interfaces/data_fetcher_interface.py

```python
"""データ取得インターフェース"""
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional
from datetime import datetime
from ...domain.value_objects.currency_pair import CurrencyPair

class DataFetcherInterface(ABC):
    """データ取得サービスのインターフェース"""

    @abstractmethod
    async def fetch_exchange_rates(
        self,
        currency_pair: CurrencyPair,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None,
        interval: str = "1m"
    ) -> List[Dict[str, Any]]:
        """為替レート取得"""
        pass

    @abstractmethod
    async def fetch_latest_rate(
        self,
        currency_pair: CurrencyPair
    ) -> Optional[Dict[str, Any]]:
        """最新レート取得"""
        pass

    @abstractmethod
    async def get_supported_pairs(self) -> List[CurrencyPair]:
        """サポートされている通貨ペア取得"""
        pass

    @abstractmethod
    async def check_api_status(self) -> Dict[str, Any]:
        """API状態チェック"""
        pass

    @abstractmethod
    async def get_rate_limits(self) -> Dict[str, Any]:
        """レート制限情報取得"""
        pass
```

### 5.2 AI Analyzer Interface

#### src/application/interfaces/ai_analyzer_interface.py

```python
"""AI分析インターフェース"""
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional

class AIAnalyzerInterface(ABC):
    """AI分析サービスのインターフェース"""

    @abstractmethod
    async def generate_market_analysis(
        self,
        market_data: Dict[str, Any],
        technical_data: Dict[str, Any],
        currency_pairs: List[str],
        custom_prompt: Optional[str] = None
    ) -> Dict[str, Any]:
        """市場分析レポート生成"""
        pass

    @abstractmethod
    async def analyze_trend(
        self,
        currency_pair: str,
        historical_data: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """トレンド分析"""
        pass

    @abstractmethod
    async def generate_signals(
        self,
        currency_pair: str,
        technical_indicators: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """売買シグナル生成"""
        pass

    @abstractmethod
    async def explain_market_movement(
        self,
        currency_pair: str,
        price_change: float,
        time_period: str
    ) -> str:
        """市場動向の説明生成"""
        pass

    @abstractmethod
    async def get_model_info(self) -> Dict[str, Any]:
        """使用モデル情報取得"""
        pass
```

### 5.3 Notifier Interface

#### src/application/interfaces/notifier_interface.py

```python
"""通知インターフェース"""
from abc import ABC, abstractmethod
from typing import Optional, Dict, Any, List
from ...domain.entities.analysis_report import AnalysisReport

class NotifierInterface(ABC):
    """通知サービスのインターフェース"""

    @abstractmethod
    async def send_discord_report(
        self,
        report: AnalysisReport
    ) -> str:
        """Discord レポート送信"""
        pass

    @abstractmethod
    async def send_discord_alert(
        self,
        title: str,
        message: str,
        level: str = "info"  # info, warning, error
    ) -> str:
        """Discord アラート送信"""
        pass

    @abstractmethod
    async def send_email(
        self,
        to_addresses: List[str],
        subject: str,
        content: str,
        content_type: str = "text/plain"
    ) -> bool:
        """メール送信"""
        pass

    @abstractmethod
    async def send_webhook(
        self,
        url: str,
        payload: Dict[str, Any],
        headers: Optional[Dict[str, str]] = None
    ) -> bool:
        """Webhook送信"""
        pass

    @abstractmethod
    async def test_notification_channel(
        self,
        channel_type: str
    ) -> Dict[str, Any]:
        """通知チャンネルテスト"""
        pass
```

## 6. DTOs (データ転送オブジェクト)

#### src/application/dto/rate_dto.py

```python
"""為替レートDTO"""
from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal
from typing import Optional

@dataclass
class RateDTO:
    """為替レートデータ転送オブジェクト"""
    currency_pair: str
    timestamp: datetime
    open_price: Decimal
    high_price: Decimal
    low_price: Decimal
    close_price: Decimal
    volume: Optional[int] = None
    source: str = "unknown"

    @classmethod
    def from_entity(cls, entity) -> 'RateDTO':
        """エンティティから変換"""
        return cls(
            currency_pair=entity.currency_pair,
            timestamp=entity.timestamp,
            open_price=entity.open_price,
            high_price=entity.high_price,
            low_price=entity.low_price,
            close_price=entity.close_price,
            volume=entity.volume,
            source=entity.source
        )

    def to_dict(self) -> dict:
        """辞書変換"""
        return {
            'currency_pair': self.currency_pair,
            'timestamp': self.timestamp.isoformat(),
            'open_price': str(self.open_price),
            'high_price': str(self.high_price),
            'low_price': str(self.low_price),
            'close_price': str(self.close_price),
            'volume': self.volume,
            'source': self.source
        }
```

この Application Layer の設計により、ドメインロジックと外部サービスを適切に分離し、テスタブルで保守性の高いユースケース実装が可能になります。
