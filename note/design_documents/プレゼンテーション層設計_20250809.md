# Presentation Layer 詳細設計

**作成日**: 2025 年 8 月 9 日
**対象**: プレゼンテーション層（API・Web・CLI）の詳細設計
**依存関係**: Application Layer のハンドラーを利用

## 1. Presentation Layer 構成

```
src/presentation/
├── api/                # REST API
│   ├── app.py         # Flask アプリケーション
│   ├── middleware/    # ミドルウェア
│   ├── routes/        # ルート定義
│   └── schemas/       # リクエスト・レスポンススキーマ
├── web/               # Web フロントエンド
│   ├── static/        # 静的ファイル
│   ├── templates/     # HTML テンプレート
│   └── controllers/   # Web コントローラー
└── cli/               # CLI インターフェース
    ├── commands.py    # CLI コマンド
    └── db_commands.py # DB 関連コマンド
```

## 2. REST API Layer

### 2.1 Flask Application

#### src/presentation/api/app.py

```python
"""Flask アプリケーション"""
from flask import Flask, request, jsonify
from flask_cors import CORS
from dependency_injector.wiring import Provide, inject
from ...core.container import Container
from .middleware.error_handler import register_error_handlers
from .middleware.auth import AuthMiddleware
from .middleware.rate_limit import RateLimitMiddleware
from .routes import (
    health_routes,
    rates_routes,
    analysis_routes,
    alerts_routes,
    ai_reports_routes,
    plugins_routes,
    github_routes
)
import logging

logger = logging.getLogger(__name__)

def create_app() -> Flask:
    """Flask アプリケーション作成"""
    app = Flask(__name__)

    # 設定読み込み
    app.config.from_object('src.config.base.BaseConfig')

    # CORS 設定
    CORS(app, origins=["http://localhost:3000", "http://localhost:8080"])

    # ミドルウェア登録
    register_middleware(app)

    # ルート登録
    register_routes(app)

    # エラーハンドラー登録
    register_error_handlers(app)

    # DI コンテナワイヤリング
    container = Container()
    container.wire(modules=[
        "src.presentation.api.routes.rates_routes",
        "src.presentation.api.routes.analysis_routes",
        "src.presentation.api.routes.ai_reports_routes",
        "src.presentation.api.routes.plugins_routes"
    ])

    logger.info("Flask application created successfully")
    return app

def register_middleware(app: Flask):
    """ミドルウェア登録"""
    # レート制限
    rate_limiter = RateLimitMiddleware()
    app.before_request(rate_limiter.check_rate_limit)

    # 認証（将来実装）
    # auth_middleware = AuthMiddleware()
    # app.before_request(auth_middleware.authenticate)

    # リクエストログ
    @app.before_request
    def log_request():
        logger.info(f"{request.method} {request.path} - {request.remote_addr}")

    # レスポンスヘッダー
    @app.after_request
    def add_security_headers(response):
        response.headers['X-Content-Type-Options'] = 'nosniff'
        response.headers['X-Frame-Options'] = 'DENY'
        response.headers['X-XSS-Protection'] = '1; mode=block'
        return response

def register_routes(app: Flask):
    """ルート登録"""
    # API バージョンプリフィックス
    api_v1 = '/api/v1'

    # ヘルスチェック
    app.register_blueprint(health_routes.bp, url_prefix='/api')

    # データ関連
    app.register_blueprint(rates_routes.bp, url_prefix=api_v1)
    app.register_blueprint(analysis_routes.bp, url_prefix=api_v1)

    # AI・レポート
    app.register_blueprint(ai_reports_routes.bp, url_prefix=api_v1)

    # アラート
    app.register_blueprint(alerts_routes.bp, url_prefix=api_v1)

    # プラグイン管理
    app.register_blueprint(plugins_routes.bp, url_prefix=api_v1)

    # GitHub連携
    app.register_blueprint(github_routes.bp, url_prefix='/api')

if __name__ == '__main__':
    app = create_app()
    app.run(
        host='0.0.0.0',
        port=8000,
        debug=True
    )
```

### 2.2 Routes

#### src/presentation/api/routes/rates_routes.py

```python
"""為替レート関連ルート"""
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import Provide, inject
from ....application.handlers.data_handler import DataHandler
from ....application.queries.get_rates_query import GetRatesQuery
from ....application.commands.fetch_rates_command import FetchRatesCommand
from ....core.container import Container
from ..schemas.rates_schema import (
    GetRatesRequestSchema,
    FetchRatesRequestSchema,
    RateResponseSchema
)
from marshmallow import ValidationError
import logging

logger = logging.getLogger(__name__)
bp = Blueprint('rates', __name__)

@bp.route('/rates', methods=['GET'])
@inject
async def get_rates(
    data_handler: DataHandler = Provide[Container.data_handler]
):
    """為替レート取得"""
    try:
        # リクエストパラメータ検証
        schema = GetRatesRequestSchema()
        query_params = schema.load(request.args)

        # クエリ作成
        query = GetRatesQuery(
            currency_pairs=query_params.get('currency_pairs'),
            start_date=query_params.get('start_date'),
            end_date=query_params.get('end_date'),
            interval=query_params.get('interval'),
            limit=query_params.get('limit', 100),
            offset=query_params.get('offset', 0)
        )

        # データ取得
        rates = await data_handler.handle_get_rates(query)

        # レスポンス作成
        response_schema = RateResponseSchema(many=True)
        response_data = response_schema.dump(rates)

        return jsonify({
            'status': 'success',
            'data': response_data,
            'count': len(rates),
            'query': {
                'currency_pairs': query.currency_pairs,
                'limit': query.limit,
                'offset': query.offset
            }
        })

    except ValidationError as e:
        return jsonify({
            'status': 'error',
            'message': 'Invalid request parameters',
            'errors': e.messages
        }), 400

    except Exception as e:
        logger.error(f"Error getting rates: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': 'Internal server error'
        }), 500

@bp.route('/rates/<currency_pair>', methods=['GET'])
@inject
async def get_rate_by_pair(
    currency_pair: str,
    data_handler: DataHandler = Provide[Container.data_handler]
):
    """特定通貨ペアのレート取得"""
    try:
        # 通貨ペアフォーマット検証
        if len(currency_pair) != 6:
            return jsonify({
                'status': 'error',
                'message': 'Invalid currency pair format'
            }), 400

        # クエリパラメータ
        limit = request.args.get('limit', 100, type=int)

        # クエリ作成
        query = GetRatesQuery(
            currency_pairs=[currency_pair.upper()],
            limit=limit
        )

        rates = await data_handler.handle_get_rates(query)

        response_schema = RateResponseSchema(many=True)
        response_data = response_schema.dump(rates)

        return jsonify({
            'status': 'success',
            'data': response_data,
            'currency_pair': currency_pair.upper(),
            'count': len(rates)
        })

    except Exception as e:
        logger.error(f"Error getting rate for {currency_pair}: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': 'Internal server error'
        }), 500

@bp.route('/rates/<currency_pair>/latest', methods=['GET'])
@inject
async def get_latest_rate(
    currency_pair: str,
    data_handler: DataHandler = Provide[Container.data_handler]
):
    """最新レート取得"""
    try:
        if len(currency_pair) != 6:
            return jsonify({
                'status': 'error',
                'message': 'Invalid currency pair format'
            }), 400

        # 最新レート取得
        latest_rates = await data_handler.handle_get_latest_rates([currency_pair.upper()])

        if currency_pair.upper() not in latest_rates:
            return jsonify({
                'status': 'error',
                'message': 'No data found for currency pair'
            }), 404

        rate = latest_rates[currency_pair.upper()]
        response_schema = RateResponseSchema()
        response_data = response_schema.dump(rate)

        return jsonify({
            'status': 'success',
            'data': response_data,
            'currency_pair': currency_pair.upper()
        })

    except Exception as e:
        logger.error(f"Error getting latest rate for {currency_pair}: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': 'Internal server error'
        }), 500

@bp.route('/rates/fetch', methods=['POST'])
@inject
async def fetch_rates(
    data_handler: DataHandler = Provide[Container.data_handler]
):
    """外部APIから為替レート取得"""
    try:
        # リクエストボディ検証
        schema = FetchRatesRequestSchema()
        request_data = schema.load(request.get_json())

        # コマンド作成
        command = FetchRatesCommand(
            currency_pairs=request_data['currency_pairs'],
            start_time=request_data.get('start_time'),
            end_time=request_data.get('end_time'),
            interval=request_data.get('interval', '1m'),
            source=request_data.get('source', 'alpha_vantage')
        )

        # データ取得実行
        rates = await data_handler.handle_fetch_rates(command)

        return jsonify({
            'status': 'success',
            'message': f'Fetched {len(rates)} rates',
            'command_id': command.command_id,
            'fetched_count': len(rates),
            'currency_pairs': command.currency_pairs
        })

    except ValidationError as e:
        return jsonify({
            'status': 'error',
            'message': 'Invalid request data',
            'errors': e.messages
        }), 400

    except Exception as e:
        logger.error(f"Error fetching rates: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': 'Internal server error'
        }), 500
```

#### src/presentation/api/routes/ai_reports_routes.py

```python
"""AI分析レポート関連ルート"""
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import Provide, inject
from datetime import date, datetime
from ....application.handlers.report_handler import ReportHandler
from ....application.commands.generate_report_command import GenerateReportCommand
from ....domain.entities.analysis_report import ReportType
from ....core.container import Container
from ..schemas.ai_reports_schema import (
    GenerateReportRequestSchema,
    ReportResponseSchema
)
from marshmallow import ValidationError
import logging

logger = logging.getLogger(__name__)
bp = Blueprint('ai_reports', __name__)

@bp.route('/ai/reports', methods=['GET'])
@inject
async def get_reports(
    report_handler: ReportHandler = Provide[Container.report_handler]
):
    """AI分析レポート一覧取得"""
    try:
        # クエリパラメータ
        report_type = request.args.get('type')
        limit = request.args.get('limit', 20, type=int)
        offset = request.args.get('offset', 0, type=int)

        # レポート取得（実装はreport_handlerに追加）
        # reports = await report_handler.handle_get_reports(report_type, limit, offset)

        # 仮実装
        reports = []

        response_schema = ReportResponseSchema(many=True)
        response_data = response_schema.dump(reports)

        return jsonify({
            'status': 'success',
            'data': response_data,
            'count': len(reports),
            'query': {
                'type': report_type,
                'limit': limit,
                'offset': offset
            }
        })

    except Exception as e:
        logger.error(f"Error getting reports: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': 'Internal server error'
        }), 500

@bp.route('/ai/reports/generate', methods=['POST'])
@inject
async def generate_report(
    report_handler: ReportHandler = Provide[Container.report_handler]
):
    """AI分析レポート生成"""
    try:
        # リクエストボディ検証
        schema = GenerateReportRequestSchema()
        request_data = schema.load(request.get_json())

        # レポートタイプ変換
        report_type = ReportType(request_data['report_type'])

        # コマンド作成
        command = GenerateReportCommand(
            report_date=request_data.get('report_date', date.today()),
            report_type=report_type,
            currency_pairs=request_data['currency_pairs'],
            custom_prompt=request_data.get('custom_prompt'),
            force_regenerate=request_data.get('force_regenerate', False)
        )

        # レポート生成実行
        report = await report_handler.handle_generate_report(command)

        response_schema = ReportResponseSchema()
        response_data = response_schema.dump(report)

        return jsonify({
            'status': 'success',
            'data': response_data,
            'command_id': command.command_id,
            'message': 'Report generated successfully'
        })

    except ValidationError as e:
        return jsonify({
            'status': 'error',
            'message': 'Invalid request data',
            'errors': e.messages
        }), 400

    except Exception as e:
        logger.error(f"Error generating report: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': 'Report generation failed',
            'error': str(e)
        }), 500

@bp.route('/ai/reports/<int:report_id>', methods=['GET'])
@inject
async def get_report(
    report_id: int,
    report_handler: ReportHandler = Provide[Container.report_handler]
):
    """特定AI分析レポート取得"""
    try:
        # レポート取得（実装はreport_handlerに追加）
        # report = await report_handler.handle_get_report_by_id(report_id)

        # 仮実装
        report = None

        if not report:
            return jsonify({
                'status': 'error',
                'message': 'Report not found'
            }), 404

        response_schema = ReportResponseSchema()
        response_data = response_schema.dump(report)

        return jsonify({
            'status': 'success',
            'data': response_data
        })

    except Exception as e:
        logger.error(f"Error getting report {report_id}: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': 'Internal server error'
        }), 500

@bp.route('/ai/reports/latest', methods=['GET'])
@inject
async def get_latest_report(
    report_handler: ReportHandler = Provide[Container.report_handler]
):
    """最新AI分析レポート取得"""
    try:
        report_type = request.args.get('type', 'daily')

        # 最新レポート取得（実装はreport_handlerに追加）
        # report = await report_handler.handle_get_latest_report(ReportType(report_type))

        # 仮実装
        report = None

        if not report:
            return jsonify({
                'status': 'error',
                'message': 'No report found'
            }), 404

        response_schema = ReportResponseSchema()
        response_data = response_schema.dump(report)

        return jsonify({
            'status': 'success',
            'data': response_data,
            'report_type': report_type
        })

    except Exception as e:
        logger.error(f"Error getting latest report: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': 'Internal server error'
        }), 500

@bp.route('/ai/reports/<int:report_id>/send', methods=['POST'])
@inject
async def send_report_to_discord(
    report_id: int,
    report_handler: ReportHandler = Provide[Container.report_handler]
):
    """レポートをDiscordに送信"""
    try:
        # レポート送信（実装はreport_handlerに追加）
        # success = await report_handler.handle_send_report_to_discord(report_id)

        # 仮実装
        success = True

        if success:
            return jsonify({
                'status': 'success',
                'message': 'Report sent to Discord successfully'
            })
        else:
            return jsonify({
                'status': 'error',
                'message': 'Failed to send report to Discord'
            }), 500

    except Exception as e:
        logger.error(f"Error sending report {report_id} to Discord: {str(e)}")
        return jsonify({
            'status': 'error',
            'message': 'Internal server error'
        }), 500
```

### 2.3 Schemas

#### src/presentation/api/schemas/rates_schema.py

```python
"""為替レート関連スキーマ"""
from marshmallow import Schema, fields, validate, validates_schema, ValidationError
from datetime import datetime

class GetRatesRequestSchema(Schema):
    """為替レート取得リクエストスキーマ"""
    currency_pairs = fields.List(
        fields.String(validate=validate.Length(equal=6)),
        missing=None
    )
    start_date = fields.DateTime(missing=None)
    end_date = fields.DateTime(missing=None)
    interval = fields.String(
        validate=validate.OneOf(['1m', '5m', '15m', '30m', '1h', '4h', '1d']),
        missing=None
    )
    limit = fields.Integer(
        validate=validate.Range(min=1, max=1000),
        missing=100
    )
    offset = fields.Integer(
        validate=validate.Range(min=0),
        missing=0
    )

    @validates_schema
    def validate_dates(self, data, **kwargs):
        """日付バリデーション"""
        start_date = data.get('start_date')
        end_date = data.get('end_date')

        if start_date and end_date:
            if start_date >= end_date:
                raise ValidationError('start_date must be before end_date')

class FetchRatesRequestSchema(Schema):
    """為替レート取得コマンドスキーマ"""
    currency_pairs = fields.List(
        fields.String(validate=validate.Length(equal=6)),
        required=True,
        validate=validate.Length(min=1, max=10)
    )
    start_time = fields.DateTime(missing=None)
    end_time = fields.DateTime(missing=None)
    interval = fields.String(
        validate=validate.OneOf(['1m', '5m', '15m', '30m', '1h', '4h', '1d']),
        missing='1m'
    )
    source = fields.String(
        validate=validate.OneOf(['alpha_vantage', 'yahoo_finance', 'mock']),
        missing='alpha_vantage'
    )

class RateResponseSchema(Schema):
    """為替レートレスポンススキーマ"""
    id = fields.Integer()
    currency_pair = fields.String()
    timestamp = fields.DateTime()
    open_price = fields.Decimal(as_string=True)
    high_price = fields.Decimal(as_string=True)
    low_price = fields.Decimal(as_string=True)
    close_price = fields.Decimal(as_string=True)
    volume = fields.Integer(allow_none=True)
    source = fields.String()
    created_at = fields.DateTime()
```

#### src/presentation/api/schemas/ai_reports_schema.py

```python
"""AI分析レポート関連スキーマ"""
from marshmallow import Schema, fields, validate, validates_schema, ValidationError
from datetime import date

class GenerateReportRequestSchema(Schema):
    """AI分析レポート生成リクエストスキーマ"""
    report_date = fields.Date(missing=lambda: date.today())
    report_type = fields.String(
        validate=validate.OneOf(['daily', 'weekly', 'event_driven', 'custom']),
        required=True
    )
    currency_pairs = fields.List(
        fields.String(validate=validate.Length(equal=6)),
        required=True,
        validate=validate.Length(min=1, max=10)
    )
    custom_prompt = fields.String(
        validate=validate.Length(max=5000),
        missing=None
    )
    force_regenerate = fields.Boolean(missing=False)

class ReportResponseSchema(Schema):
    """AI分析レポートレスポンススキーマ"""
    id = fields.Integer()
    report_date = fields.Date()
    report_type = fields.String()
    status = fields.String()
    title = fields.String()
    market_summary = fields.String()
    technical_analysis = fields.String()
    fundamental_analysis = fields.String(allow_none=True)
    recommendations = fields.String(allow_none=True)
    currency_pairs_analyzed = fields.List(fields.String())
    confidence_score = fields.Decimal(as_string=True, allow_none=True)
    ai_model_used = fields.String()
    generation_time_seconds = fields.Float(allow_none=True)
    discord_message_id = fields.String(allow_none=True)
    created_at = fields.DateTime()

    class Meta:
        exclude = ['error_message']  # エラーメッセージは通常のレスポンスでは除外
```

### 2.4 Middleware

#### src/presentation/api/middleware/rate_limit.py

```python
"""レート制限ミドルウェア"""
import time
from typing import Dict, Any
from flask import request, jsonify, g
from collections import defaultdict, deque
import logging

logger = logging.getLogger(__name__)

class RateLimitMiddleware:
    """レート制限ミドルウェア"""

    def __init__(self):
        self.rate_limits = {
            # エンドポイント別制限
            '/api/v1/rates/fetch': {'requests': 10, 'window': 60},  # 1分10回
            '/api/v1/ai/reports/generate': {'requests': 5, 'window': 300},  # 5分5回
            'default': {'requests': 100, 'window': 60}  # デフォルト制限
        }

        # IPアドレス別リクエスト履歴
        self.request_history: Dict[str, Dict[str, deque]] = defaultdict(
            lambda: defaultdict(deque)
        )

    def check_rate_limit(self) -> Any:
        """レート制限チェック"""
        try:
            # 除外パス
            if self._should_skip_rate_limit():
                return None

            client_ip = self._get_client_ip()
            endpoint = self._get_endpoint_key()

            # レート制限設定取得
            limit_config = self.rate_limits.get(endpoint, self.rate_limits['default'])
            max_requests = limit_config['requests']
            time_window = limit_config['window']

            # リクエスト履歴更新
            current_time = time.time()
            self._cleanup_old_requests(client_ip, endpoint, current_time, time_window)

            # 現在のリクエスト数チェック
            request_count = len(self.request_history[client_ip][endpoint])

            if request_count >= max_requests:
                logger.warning(
                    f"Rate limit exceeded for {client_ip} on {endpoint}: "
                    f"{request_count}/{max_requests}"
                )
                return jsonify({
                    'status': 'error',
                    'message': 'Rate limit exceeded',
                    'retry_after': time_window
                }), 429

            # リクエスト記録
            self.request_history[client_ip][endpoint].append(current_time)

            # レスポンスヘッダー用情報を設定
            g.rate_limit_remaining = max_requests - request_count - 1
            g.rate_limit_limit = max_requests
            g.rate_limit_reset = int(current_time + time_window)

            return None

        except Exception as e:
            logger.error(f"Rate limit check error: {str(e)}")
            # エラー時はレート制限をスキップ
            return None

    def _should_skip_rate_limit(self) -> bool:
        """レート制限をスキップすべきかチェック"""
        skip_paths = [
            '/api/health',
            '/api/github/webhook',  # GitHubウェブフックは除外
        ]

        return any(request.path.startswith(path) for path in skip_paths)

    def _get_client_ip(self) -> str:
        """クライアントIP取得"""
        # プロキシ経由の場合を考慮
        forwarded_ips = request.headers.get('X-Forwarded-For')
        if forwarded_ips:
            return forwarded_ips.split(',')[0].strip()

        real_ip = request.headers.get('X-Real-IP')
        if real_ip:
            return real_ip

        return request.remote_addr or 'unknown'

    def _get_endpoint_key(self) -> str:
        """エンドポイントキー取得"""
        # パスパラメータを正規化
        path = request.path

        # 動的パラメータを置換
        for pattern, replacement in [
            (r'/\d+', '/{id}'),
            (r'/[A-Z]{6}', '/{currency_pair}'),
        ]:
            import re
            path = re.sub(pattern, replacement, path)

        return f"{request.method} {path}"

    def _cleanup_old_requests(
        self,
        client_ip: str,
        endpoint: str,
        current_time: float,
        time_window: int
    ):
        """古いリクエスト履歴削除"""
        cutoff_time = current_time - time_window
        request_queue = self.request_history[client_ip][endpoint]

        while request_queue and request_queue[0] < cutoff_time:
            request_queue.popleft()
```

## 3. Web Frontend

### 3.1 Templates

#### src/presentation/web/templates/base.html

```html
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{% block title %}Exchange Analytics{% endblock %}</title>

    <!-- Bootstrap CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- カスタムCSS -->
    <link
      href="{{ url_for('static', filename='css/style.css') }}"
      rel="stylesheet"
    />

    {% block head %}{% endblock %}
  </head>
  <body>
    <!-- ナビゲーション -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
      <div class="container">
        <a class="navbar-brand" href="{{ url_for('web.dashboard') }}">
          <i class="fas fa-chart-line"></i> Exchange Analytics
        </a>

        <button
          class="navbar-toggler"
          type="button"
          data-bs-toggle="collapse"
          data-bs-target="#navbarNav"
        >
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarNav">
          <ul class="navbar-nav me-auto">
            <li class="nav-item">
              <a class="nav-link" href="{{ url_for('web.dashboard') }}">
                <i class="fas fa-tachometer-alt"></i> ダッシュボード
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="{{ url_for('web.charts') }}">
                <i class="fas fa-chart-area"></i> チャート
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="{{ url_for('web.analysis') }}">
                <i class="fas fa-brain"></i> AI分析
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="{{ url_for('web.alerts') }}">
                <i class="fas fa-bell"></i> アラート
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="{{ url_for('web.settings') }}">
                <i class="fas fa-cog"></i> 設定
              </a>
            </li>
          </ul>

          <ul class="navbar-nav">
            <li class="nav-item">
              <span class="navbar-text">
                <i class="fas fa-clock"></i>
                <span id="current-time"></span>
              </span>
            </li>
          </ul>
        </div>
      </div>
    </nav>

    <!-- メインコンテンツ -->
    <main class="container-fluid mt-4">
      {% with messages = get_flashed_messages(with_categories=true) %} {% if
      messages %} {% for category, message in messages %}
      <div
        class="alert alert-{{ 'danger' if category == 'error' else category }} alert-dismissible fade show"
        role="alert"
      >
        {{ message }}
        <button
          type="button"
          class="btn-close"
          data-bs-dismiss="alert"
        ></button>
      </div>
      {% endfor %} {% endif %} {% endwith %} {% block content %}{% endblock %}
    </main>

    <!-- Footer -->
    <footer class="bg-dark text-light mt-5 py-3">
      <div class="container">
        <div class="row">
          <div class="col-md-6">
            <p>&copy; 2025 Exchange Analytics. All rights reserved.</p>
          </div>
          <div class="col-md-6 text-end">
            <p>Powered by AI & Real-time Data</p>
          </div>
        </div>
      </div>
    </footer>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Font Awesome -->
    <script src="https://kit.fontawesome.com/your-fontawesome-kit.js"></script>

    <!-- カスタムJS -->
    <script src="{{ url_for('static', filename='js/common.js') }}"></script>

    {% block scripts %}{% endblock %}
  </body>
</html>
```

### 3.2 Static Files

#### src/presentation/web/static/js/dashboard.js

```javascript
/**
 * ダッシュボード用JavaScript
 */

class DashboardController {
  constructor() {
    this.charts = {};
    this.updateInterval = 60000; // 1分間隔
    this.init();
  }

  async init() {
    try {
      await this.loadInitialData();
      this.setupCharts();
      this.setupAutoUpdate();
      this.setupEventListeners();
    } catch (error) {
      console.error("Dashboard initialization failed:", error);
      this.showError("ダッシュボードの初期化に失敗しました");
    }
  }

  async loadInitialData() {
    const majorPairs = ["USDJPY", "EURJPY", "GBPJPY", "AUDJPY"];

    // 並列で最新レート取得
    const ratePromises = majorPairs.map((pair) => this.fetchLatestRate(pair));

    const rates = await Promise.all(ratePromises);

    // レート表示更新
    rates.forEach((rate, index) => {
      if (rate) {
        this.updateRateDisplay(majorPairs[index], rate);
      }
    });
  }

  async fetchLatestRate(currencyPair) {
    try {
      const response = await fetch(`/api/v1/rates/${currencyPair}/latest`);
      const data = await response.json();

      if (data.status === "success") {
        return data.data;
      } else {
        console.warn(`Failed to fetch rate for ${currencyPair}:`, data.message);
        return null;
      }
    } catch (error) {
      console.error(`Error fetching rate for ${currencyPair}:`, error);
      return null;
    }
  }

  updateRateDisplay(currencyPair, rateData) {
    const container = document.getElementById(
      `rate-${currencyPair.toLowerCase()}`
    );
    if (!container) return;

    const price = parseFloat(rateData.close_price);
    const openPrice = parseFloat(rateData.open_price);
    const change = price - openPrice;
    const changePercent = (change / openPrice) * 100;

    // 価格表示
    const priceElement = container.querySelector(".current-price");
    if (priceElement) {
      priceElement.textContent = price.toFixed(this.getPrecision(currencyPair));
    }

    // 変動表示
    const changeElement = container.querySelector(".price-change");
    if (changeElement) {
      const isPositive = change >= 0;
      changeElement.textContent = `${isPositive ? "+" : ""}${change.toFixed(
        4
      )} (${changePercent.toFixed(2)}%)`;
      changeElement.className = `price-change ${
        isPositive ? "text-success" : "text-danger"
      }`;
    }

    // 最終更新時刻
    const timeElement = container.querySelector(".last-updated");
    if (timeElement) {
      const updateTime = new Date(rateData.timestamp);
      timeElement.textContent = updateTime.toLocaleString("ja-JP");
    }

    // 価格変動アニメーション
    this.animatePriceChange(container, change >= 0);
  }

  animatePriceChange(container, isPositive) {
    const flashClass = isPositive ? "flash-green" : "flash-red";
    container.classList.add(flashClass);

    setTimeout(() => {
      container.classList.remove(flashClass);
    }, 1000);
  }

  getPrecision(currencyPair) {
    // 円ペアは3桁、その他は5桁
    return currencyPair.includes("JPY") ? 3 : 5;
  }

  setupCharts() {
    // ミニチャート設定
    const chartElements = document.querySelectorAll(".mini-chart");

    chartElements.forEach(async (element) => {
      const currencyPair = element.dataset.pair;
      await this.createMiniChart(element, currencyPair);
    });
  }

  async createMiniChart(canvas, currencyPair) {
    try {
      // 過去24時間のデータ取得
      const response = await fetch(`/api/v1/rates/${currencyPair}?limit=24`);
      const data = await response.json();

      if (data.status !== "success" || !data.data.length) {
        return;
      }

      const rates = data.data;
      const labels = rates.map(
        (rate) => new Date(rate.timestamp).getHours() + ":00"
      );
      const prices = rates.map((rate) => parseFloat(rate.close_price));

      const chart = new Chart(canvas, {
        type: "line",
        data: {
          labels: labels,
          datasets: [
            {
              data: prices,
              borderColor: "#007bff",
              backgroundColor: "rgba(0, 123, 255, 0.1)",
              borderWidth: 2,
              fill: true,
              tension: 0.4,
              pointRadius: 0,
              pointHoverRadius: 4,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false,
            },
          },
          scales: {
            x: {
              display: false,
            },
            y: {
              display: false,
            },
          },
          interaction: {
            intersect: false,
            mode: "index",
          },
        },
      });

      this.charts[currencyPair] = chart;
    } catch (error) {
      console.error(`Error creating chart for ${currencyPair}:`, error);
    }
  }

  setupAutoUpdate() {
    // 定期更新
    setInterval(() => {
      this.loadInitialData();
    }, this.updateInterval);
  }

  setupEventListeners() {
    // 手動リフレッシュボタン
    const refreshBtn = document.getElementById("refresh-btn");
    if (refreshBtn) {
      refreshBtn.addEventListener("click", () => {
        this.loadInitialData();
      });
    }

    // 通貨ペア選択変更
    const pairSelectors = document.querySelectorAll(".pair-selector");
    pairSelectors.forEach((selector) => {
      selector.addEventListener("change", (e) => {
        this.updateDisplayedPair(e.target);
      });
    });
  }

  showError(message) {
    const alertHtml = `
            <div class="alert alert-danger alert-dismissible fade show" role="alert">
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            </div>
        `;

    const alertContainer =
      document.getElementById("alert-container") || document.body;
    alertContainer.insertAdjacentHTML("afterbegin", alertHtml);
  }

  showSuccess(message) {
    const alertHtml = `
            <div class="alert alert-success alert-dismissible fade show" role="alert">
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            </div>
        `;

    const alertContainer =
      document.getElementById("alert-container") || document.body;
    alertContainer.insertAdjacentHTML("afterbegin", alertHtml);
  }
}

// ダッシュボード初期化
document.addEventListener("DOMContentLoaded", () => {
  new DashboardController();
});
```

## 4. CLI Interface

#### src/presentation/cli/commands.py

```python
"""CLI コマンド"""
import click
import asyncio
from datetime import datetime, date
from ...application.commands.fetch_rates_command import FetchRatesCommand
from ...application.commands.generate_report_command import GenerateReportCommand
from ...domain.entities.analysis_report import ReportType
from ...core.container import Container

@click.group()
def cli():
    """Exchange Analytics CLI"""
    pass

@cli.command()
@click.option('--pairs', '-p', multiple=True, required=True, help='Currency pairs (e.g., USDJPY)')
@click.option('--interval', '-i', default='1h', help='Data interval')
@click.option('--source', '-s', default='alpha_vantage', help='Data source')
def fetch_rates(pairs, interval, source):
    """為替レート取得"""
    async def _fetch():
        container = Container()
        data_handler = container.data_handler()

        command = FetchRatesCommand(
            currency_pairs=list(pairs),
            interval=interval,
            source=source
        )

        try:
            rates = await data_handler.handle_fetch_rates(command)
            click.echo(f"Successfully fetched {len(rates)} rates")

            for rate in rates[:5]:  # 最初の5件表示
                click.echo(f"{rate.currency_pair}: {rate.close_price} at {rate.timestamp}")

        except Exception as e:
            click.echo(f"Error: {str(e)}", err=True)

    asyncio.run(_fetch())

@cli.command()
@click.option('--type', '-t', default='daily', type=click.Choice(['daily', 'weekly', 'custom']))
@click.option('--pairs', '-p', multiple=True, default=['USDJPY', 'EURJPY'])
@click.option('--force', is_flag=True, help='Force regenerate existing report')
def generate_report(type, pairs, force):
    """AI分析レポート生成"""
    async def _generate():
        container = Container()
        report_handler = container.report_handler()

        command = GenerateReportCommand(
            report_date=date.today(),
            report_type=ReportType(type),
            currency_pairs=list(pairs),
            force_regenerate=force
        )

        try:
            with click.progressbar(length=100, label='Generating report') as bar:
                # 進捗表示の仮実装
                for i in range(100):
                    bar.update(1)
                    await asyncio.sleep(0.1)

            report = await report_handler.handle_generate_report(command)

            click.echo(f"\nReport generated successfully!")
            click.echo(f"Title: {report.title}")
            click.echo(f"Confidence: {report.confidence_score}")
            click.echo(f"Report ID: {report.id}")

        except Exception as e:
            click.echo(f"Error: {str(e)}", err=True)

    asyncio.run(_generate())

if __name__ == '__main__':
    cli()
```

この Presentation Layer の設計により、REST API、Web フロントエンド、CLI の 3 つのインターフェースで統一された機能を提供できます。各層が適切に分離されており、独立してテスト・開発が可能な構造になっています。
