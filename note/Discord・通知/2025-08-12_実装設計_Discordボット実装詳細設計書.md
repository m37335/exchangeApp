# Discord ボット実装詳細設計書

**旧ファイル名**: `実装詳細設計書.md`  

## 🚀 実装概要

### プロジェクト構成

```
discord_usdjpy_bot/
├── main.py                    # エントリーポイント
├── config/
│   ├── __init__.py
│   ├── settings.py           # 設定管理
│   └── database.py           # データベース設定
├── bot/
│   ├── __init__.py
│   ├── client.py             # Discord Bot Client
│   ├── commands.py           # コマンドハンドラー
│   ├── permissions.py        # 権限管理
│   └── responses.py          # レスポンス生成
├── services/
│   ├── __init__.py
│   ├── analysis_service.py   # 分析サービス
│   ├── cache_service.py      # キャッシュサービス
│   ├── rate_limit.py         # レート制限
│   └── discord_service.py    # Discord配信サービス
├── models/
│   ├── __init__.py
│   ├── user.py               # ユーザーモデル
│   ├── analysis.py           # 分析モデル
│   └── database.py           # データベースモデル
├── utils/
│   ├── __init__.py
│   ├── logger.py             # ログ機能
│   ├── formatter.py          # フォーマット機能
│   └── validators.py         # バリデーション
└── tests/
    ├── __init__.py
    ├── test_commands.py
    ├── test_analysis.py
    └── test_permissions.py
```

## 🔧 核心実装

### 1. Discord Bot Client 実装

#### main.py

```python
import asyncio
import discord
from discord.ext import commands
from config.settings import Settings
from bot.client import USDJPYBot
from utils.logger import setup_logger

async def main():
    # ログ設定
    setup_logger()

    # 設定読み込み
    settings = Settings()

    # Bot初期化
    intents = discord.Intents.default()
    intents.message_content = True
    intents.members = True

    bot = USDJPYBot(
        command_prefix='!',
        intents=intents,
        settings=settings
    )

    # コグ読み込み
    await bot.load_extension('bot.commands')
    await bot.load_extension('bot.permissions')

    # Bot起動
    await bot.start(settings.DISCORD_TOKEN)

if __name__ == "__main__":
    asyncio.run(main())
```

#### bot/client.py

```python
import discord
from discord.ext import commands
from typing import Optional
from config.settings import Settings
from services.analysis_service import AnalysisService
from services.cache_service import CacheService
from services.rate_limit import RateLimiter

class USDJPYBot(commands.Bot):
    def __init__(self, settings: Settings, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.settings = settings
        self.analysis_service = AnalysisService()
        self.cache_service = CacheService()
        self.rate_limiter = RateLimiter()

    async def setup_hook(self):
        """Bot起動時の初期化処理"""
        await self.analysis_service.initialize()
        await self.cache_service.initialize()

    async def on_ready(self):
        """Bot準備完了時の処理"""
        print(f'{self.user} としてログインしました')
        await self.change_presence(
            activity=discord.Activity(
                type=discord.ActivityType.watching,
                name="USD/JPY Analysis"
            )
        )

    async def on_message(self, message):
        """メッセージ受信時の処理"""
        if message.author.bot:
            return

        # ハッシュタグコマンド検出
        if message.content.startswith('#'):
            await self.handle_hashtag_command(message)
        else:
            await self.process_commands(message)

    async def handle_hashtag_command(self, message):
        """ハッシュタグコマンド処理"""
        from bot.commands import AnalysisCommands
        commands_handler = AnalysisCommands(self)
        await commands_handler.handle_hashtag_command(message)
```

### 2. コマンドハンドラー実装

#### bot/commands.py

```python
import discord
from discord.ext import commands
import re
from typing import Dict, Any, Optional
from services.analysis_service import AnalysisService
from services.rate_limit import RateLimiter
from bot.permissions import PermissionManager
from bot.responses import ResponseFormatter

class AnalysisCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.analysis_service = bot.analysis_service
        self.rate_limiter = bot.rate_limiter
        self.permission_manager = PermissionManager()
        self.response_formatter = ResponseFormatter()

    @commands.Cog.listener()
    async def on_message(self, message):
        """メッセージリスナー"""
        if message.author.bot:
            return

        # ハッシュタグコマンド検出
        if message.content.startswith('#'):
            await self.handle_hashtag_command(message)

    async def handle_hashtag_command(self, message):
        """ハッシュタグコマンド処理"""
        try:
            # コマンド解析
            command_data = self.parse_hashtag_command(message.content)
            if not command_data:
                return

            # 権限チェック
            if not await self.permission_manager.check_permission(
                message.author, command_data['command']
            ):
                await message.channel.send(
                    "❌ このコマンドを実行する権限がありません。"
                )
                return

            # レート制限チェック
            if not await self.rate_limiter.check_limit(
                message.author.id, command_data['command']
            ):
                await message.channel.send(
                    "⏰ レート制限に達しました。しばらく待ってから再試行してください。"
                )
                return

            # 分析実行
            await self.execute_analysis(message, command_data)

        except Exception as e:
            await message.channel.send(f"❌ エラーが発生しました: {str(e)}")

    def parse_hashtag_command(self, content: str) -> Optional[Dict[str, Any]]:
        """ハッシュタグコマンド解析"""
        # コマンドパターン定義
        patterns = {
            r'#usdjpy\s*(\w+)?\s*(\w+)?': {
                'command': 'usdjpy',
                'params': ['timeframe', 'detail']
            },
            r'#analyze\s*(\w+)?\s*(\w+)?\s*(\w+)?': {
                'command': 'analyze',
                'params': ['currency', 'timeframe', 'options']
            },
            r'#forecast\s*(\w+)?\s*(\w+)?': {
                'command': 'forecast',
                'params': ['period', 'confidence']
            },
            r'#stats': {
                'command': 'stats',
                'params': []
            },
            r'#help': {
                'command': 'help',
                'params': []
            }
        }

        for pattern, config in patterns.items():
            match = re.match(pattern, content, re.IGNORECASE)
            if match:
                params = {}
                for i, param_name in enumerate(config['params']):
                    if i + 1 < len(match.groups()) and match.group(i + 1):
                        params[param_name] = match.group(i + 1)

                return {
                    'command': config['command'],
                    'params': params
                }

        return None

    async def execute_analysis(self, message, command_data):
        """分析実行"""
        # 処理中メッセージ送信
        processing_msg = await message.channel.send(
            "🔄 分析を実行中です... しばらくお待ちください。"
        )

        try:
            # 分析実行
            result = await self.analysis_service.execute_analysis(
                command_data['command'],
                command_data['params'],
                message.author.id
            )

            # レスポンス生成
            embed = self.response_formatter.create_analysis_embed(result)

            # 結果送信
            await processing_msg.delete()
            await message.channel.send(embed=embed)

        except Exception as e:
            await processing_msg.delete()
            await message.channel.send(f"❌ 分析実行中にエラーが発生しました: {str(e)}")
```

### 3. 分析サービス実装

#### services/analysis_service.py

```python
import asyncio
from typing import Dict, Any, Optional
from services.cache_service import CacheService
from utils.logger import get_logger

logger = get_logger(__name__)

class AnalysisService:
    def __init__(self):
        self.cache_service = CacheService()
        self.correlation_analyzer = None
        self.technical_analyzer = None

    async def initialize(self):
        """初期化処理"""
        # 既存の分析コンポーネントを統合
        from src.infrastructure.analysis.currency_correlation_analyzer import (
            CurrencyCorrelationAnalyzer
        )
        from src.infrastructure.analysis.technical_indicators import (
            TechnicalIndicatorsAnalyzer
        )

        self.correlation_analyzer = CurrencyCorrelationAnalyzer()
        self.technical_analyzer = TechnicalIndicatorsAnalyzer()

    async def execute_analysis(
        self,
        command: str,
        params: Dict[str, Any],
        user_id: str
    ) -> Dict[str, Any]:
        """分析実行"""
        # キャッシュキー生成
        cache_key = self._generate_cache_key(command, params)

        # キャッシュチェック
        cached_result = await self.cache_service.get_analysis(cache_key)
        if cached_result:
            logger.info(f"Cache hit for key: {cache_key}")
            return cached_result

        # 分析実行
        if command == 'usdjpy':
            result = await self._execute_usdjpy_analysis(params)
        elif command == 'analyze':
            result = await self._execute_detailed_analysis(params)
        elif command == 'forecast':
            result = await self._execute_forecast_analysis(params)
        else:
            raise ValueError(f"Unknown command: {command}")

        # キャッシュ保存
        await self.cache_service.cache_analysis(cache_key, result, ttl=300)

        return result

    async def _execute_usdjpy_analysis(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """USD/JPY基本分析"""
        # 通貨相関分析
        correlation_data = await self.correlation_analyzer.perform_integrated_analysis()

        # テクニカル分析
        timeframe = params.get('timeframe', '1h')
        technical_data = await self._get_technical_indicators('USD/JPY', timeframe)

        # AI分析生成
        ai_analysis = await self._generate_ai_analysis(correlation_data, technical_data)

        return {
            'type': 'usdjpy_analysis',
            'correlation_data': correlation_data,
            'technical_data': technical_data,
            'ai_analysis': ai_analysis,
            'timestamp': asyncio.get_event_loop().time()
        }

    async def _execute_detailed_analysis(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """詳細分析"""
        currency = params.get('currency', 'USDJPY')
        timeframe = params.get('timeframe', '1h')

        # 詳細な分析を実行
        result = await self._execute_usdjpy_analysis(params)
        result['type'] = 'detailed_analysis'
        result['currency'] = currency

        return result

    async def _execute_forecast_analysis(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """予測分析"""
        period = params.get('period', '1d')
        confidence = params.get('confidence', 'medium')

        # 予測分析を実行
        result = await self._execute_usdjpy_analysis(params)
        result['type'] = 'forecast_analysis'
        result['forecast_period'] = period
        result['confidence_level'] = confidence

        return result

    async def _get_technical_indicators(self, currency_pair: str, timeframe: str):
        """テクニカル指標取得"""
        # 既存のテクニカル分析機能を統合
        from scripts.cron.integrated_ai_discord import IntegratedAIDiscordReporter

        reporter = IntegratedAIDiscordReporter()
        await reporter.initialize_optimization_components()

        return await reporter._fetch_technical_indicators(currency_pair)

    async def _generate_ai_analysis(self, correlation_data: Dict, technical_data: Dict):
        """AI分析生成"""
        # 既存のAI分析機能を統合
        from scripts.cron.integrated_ai_discord import IntegratedAIDiscordReporter

        reporter = IntegratedAIDiscordReporter()
        return await reporter.generate_integrated_analysis(correlation_data, technical_data)

    def _generate_cache_key(self, command: str, params: Dict[str, Any]) -> str:
        """キャッシュキー生成"""
        param_str = "_".join([f"{k}_{v}" for k, v in sorted(params.items())])
        return f"{command}_{param_str}"
```

### 4. レスポンスフォーマッター実装

#### bot/responses.py

```python
import discord
from typing import Dict, Any
from datetime import datetime
import pytz

class ResponseFormatter:
    def __init__(self):
        self.jst = pytz.timezone("Asia/Tokyo")

    def create_analysis_embed(self, result: Dict[str, Any]) -> discord.Embed:
        """分析結果のEmbed作成"""
        analysis_type = result.get('type', 'unknown')

        if analysis_type == 'usdjpy_analysis':
            return self._create_usdjpy_embed(result)
        elif analysis_type == 'detailed_analysis':
            return self._create_detailed_embed(result)
        elif analysis_type == 'forecast_analysis':
            return self._create_forecast_embed(result)
        else:
            return self._create_error_embed("Unknown analysis type")

    def _create_usdjpy_embed(self, result: Dict[str, Any]) -> discord.Embed:
        """USD/JPY分析Embed作成"""
        correlation_data = result.get('correlation_data', {})
        ai_analysis = result.get('ai_analysis', '')

        # 基本情報取得
        usdjpy_forecast = correlation_data.get('usdjpy_forecast', {})
        current_rate = usdjpy_forecast.get('current_rate', 0)
        strategy_bias = usdjpy_forecast.get('strategy_bias', 'NEUTRAL')
        forecast_confidence = usdjpy_forecast.get('forecast_confidence', 0)

        # 色設定
        color = self._get_strategy_color(strategy_bias)

        # Embed作成
        embed = discord.Embed(
            title="🎯 USD/JPY AI Analysis",
            description="通貨相関性を活用したAI統合分析",
            color=color,
            timestamp=datetime.now(self.jst)
        )

        # フィールド追加
        embed.add_field(
            name="📊 Current Rate",
            value=f"**{current_rate:.4f}**",
            inline=True
        )

        embed.add_field(
            name="🎯 Strategy",
            value=f"**{strategy_bias}** ({forecast_confidence}%)",
            inline=True
        )

        embed.add_field(
            name="📈 Analysis",
            value=ai_analysis[:1000] + "..." if len(ai_analysis) > 1000 else ai_analysis,
            inline=False
        )

        embed.set_footer(text="USD/JPY AI Analysis Bot")

        return embed

    def _create_detailed_embed(self, result: Dict[str, Any]) -> discord.Embed:
        """詳細分析Embed作成"""
        embed = self._create_usdjpy_embed(result)
        embed.title = "🔍 Detailed USD/JPY Analysis"

        # 詳細情報を追加
        technical_data = result.get('technical_data', {})
        if technical_data:
            tech_summary = self._format_technical_summary(technical_data)
            embed.add_field(
                name="📊 Technical Summary",
                value=tech_summary,
                inline=False
            )

        return embed

    def _create_forecast_embed(self, result: Dict[str, Any]) -> discord.Embed:
        """予測分析Embed作成"""
        embed = self._create_usdjpy_embed(result)
        embed.title = "🔮 USD/JPY Forecast Analysis"

        # 予測情報を追加
        period = result.get('forecast_period', '1d')
        confidence = result.get('confidence_level', 'medium')

        embed.add_field(
            name="⏰ Forecast Period",
            value=f"**{period}**",
            inline=True
        )

        embed.add_field(
            name="🎯 Confidence Level",
            value=f"**{confidence.upper()}**",
            inline=True
        )

        return embed

    def _create_error_embed(self, error_message: str) -> discord.Embed:
        """エラーEmbed作成"""
        embed = discord.Embed(
            title="❌ Analysis Error",
            description=error_message,
            color=0xFF0000,
            timestamp=datetime.now(self.jst)
        )

        embed.set_footer(text="USD/JPY AI Analysis Bot")
        return embed

    def _get_strategy_color(self, strategy_bias: str) -> int:
        """戦略バイアスに基づく色取得"""
        color_map = {
            'LONG': 0x00FF00,    # 緑色
            'SHORT': 0xFF0000,   # 赤色
            'NEUTRAL': 0xFFFF00  # 黄色
        }
        return color_map.get(strategy_bias, 0x808080)  # グレー

    def _format_technical_summary(self, technical_data: Dict[str, Any]) -> str:
        """テクニカル指標サマリー作成"""
        summary = []

        for timeframe in ['D1', 'H4', 'H1', 'M5']:
            if f"{timeframe}_RSI_SHORT" in technical_data:
                rsi_data = technical_data[f"{timeframe}_RSI_SHORT"]
                rsi_val = rsi_data.get('current_value', 'N/A')
                if isinstance(rsi_val, (int, float)):
                    summary.append(f"{timeframe}: RSI={rsi_val:.1f}")

        return " | ".join(summary) if summary else "No technical data available"
```

### 5. レート制限実装

#### services/rate_limit.py

```python
import asyncio
import time
from typing import Dict, Any
from collections import defaultdict
import redis
from config.settings import Settings

class RateLimiter:
    def __init__(self):
        self.settings = Settings()
        self.redis_client = None
        self.memory_limits = defaultdict(list)

    async def initialize(self):
        """初期化"""
        try:
            self.redis_client = redis.Redis.from_url(self.settings.REDIS_URL)
            await self.redis_client.ping()
        except Exception as e:
            print(f"Redis connection failed, using memory storage: {e}")
            self.redis_client = None

    async def check_limit(self, user_id: str, command: str) -> bool:
        """レート制限チェック"""
        # 制限設定
        limits = {
            'usdjpy': {'calls': 1, 'window': 60},    # 1分間に1回
            'analyze': {'calls': 3, 'window': 60},   # 1分間に3回
            'forecast': {'calls': 2, 'window': 60},  # 1分間に2回
            'stats': {'calls': 10, 'window': 60},    # 1分間に10回
            'help': {'calls': 5, 'window': 60}       # 1分間に5回
        }

        limit_config = limits.get(command, {'calls': 1, 'window': 60})

        if self.redis_client:
            return await self._check_redis_limit(user_id, command, limit_config)
        else:
            return self._check_memory_limit(user_id, command, limit_config)

    async def _check_redis_limit(self, user_id: str, command: str, limit_config: Dict[str, Any]) -> bool:
        """Redisベースのレート制限チェック"""
        key = f"rate_limit:{user_id}:{command}"
        current_time = int(time.time())
        window = limit_config['window']
        max_calls = limit_config['calls']

        # 古いエントリを削除
        await self.redis_client.zremrangebyscore(key, 0, current_time - window)

        # 現在の呼び出し数を取得
        current_calls = await self.redis_client.zcard(key)

        if current_calls >= max_calls:
            return False

        # 新しい呼び出しを記録
        await self.redis_client.zadd(key, {str(current_time): current_time})
        await self.redis_client.expire(key, window)

        return True

    def _check_memory_limit(self, user_id: str, command: str, limit_config: Dict[str, Any]) -> bool:
        """メモリベースのレート制限チェック"""
        key = f"{user_id}:{command}"
        current_time = time.time()
        window = limit_config['window']
        max_calls = limit_config['calls']

        # 古いエントリを削除
        self.memory_limits[key] = [
            timestamp for timestamp in self.memory_limits[key]
            if current_time - timestamp < window
        ]

        # 現在の呼び出し数をチェック
        if len(self.memory_limits[key]) >= max_calls:
            return False

        # 新しい呼び出しを記録
        self.memory_limits[key].append(current_time)

        return True
```

## 🚀 デプロイメント設定

### requirements.txt

```
discord.py==2.3.2
fastapi==0.104.1
uvicorn==0.24.0
redis==5.0.1
sqlalchemy==2.0.23
psycopg2-binary==2.9.9
pydantic==2.5.0
python-dotenv==1.0.0
pytz==2023.3
httpx==0.25.2
rich==13.7.0
```

### Dockerfile

```dockerfile
FROM python:3.11-slim

WORKDIR /app

# 依存関係インストール
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# アプリケーションコピー
COPY . .

# 環境変数設定
ENV PYTHONPATH=/app
ENV PYTHONUNBUFFERED=1

# 実行
CMD ["python", "main.py"]
```

### docker-compose.yml

```yaml
version: "3.8"

services:
  discord-bot:
    build: .
    environment:
      - DISCORD_TOKEN=${DISCORD_TOKEN}
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
    depends_on:
      - postgres
      - redis
    restart: unless-stopped

  postgres:
    image: postgres:13
    environment:
      - POSTGRES_DB=usdjpy_bot
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:6-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

## 📊 監視・ログ設定

### ログ設定

```python
# utils/logger.py
import logging
import sys
from logging.handlers import RotatingFileHandler

def setup_logger():
    """ログ設定"""
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)

    # フォーマッター
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )

    # ファイルハンドラー
    file_handler = RotatingFileHandler(
        'discord_bot.log',
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5
    )
    file_handler.setFormatter(formatter)

    # コンソールハンドラー
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)

    logger.addHandler(file_handler)
    logger.addHandler(console_handler)
```

## 🧪 テスト実装

### テスト例

```python
# tests/test_commands.py
import pytest
from unittest.mock import Mock, AsyncMock
from bot.commands import AnalysisCommands

@pytest.fixture
def mock_bot():
    bot = Mock()
    bot.analysis_service = AsyncMock()
    bot.rate_limiter = AsyncMock()
    return bot

@pytest.fixture
def commands_handler(mock_bot):
    return AnalysisCommands(mock_bot)

@pytest.mark.asyncio
async def test_parse_usdjpy_command(commands_handler):
    """USD/JPYコマンド解析テスト"""
    content = "#usdjpy 1h basic"
    result = commands_handler.parse_hashtag_command(content)

    assert result is not None
    assert result['command'] == 'usdjpy'
    assert result['params']['timeframe'] == '1h'
    assert result['params']['detail'] == 'basic'

@pytest.mark.asyncio
async def test_rate_limit_check(commands_handler):
    """レート制限テスト"""
    commands_handler.bot.rate_limiter.check_limit.return_value = False

    message = Mock()
    message.author.id = "123456"
    message.channel.send = AsyncMock()

    await commands_handler.handle_hashtag_command(message)

    message.channel.send.assert_called_with(
        "⏰ レート制限に達しました。しばらく待ってから再試行してください。"
    )
```

---

**作成日**: 2025 年 8 月 12 日
**作成者**: AI Assistant
**バージョン**: 1.0
