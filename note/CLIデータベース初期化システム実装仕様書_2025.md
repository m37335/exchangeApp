# CLI データベース初期化システム実装仕様書

## 📋 概要

### 目的

- 設計書に基づく具体的な実装仕様の定義
- 基盤データを基準とした差分更新システムの詳細設計
- 各ファイルの依存関係とクラス設計の詳細化
- 処理フローとメソッドの具体的な機能定義

### 基本方針

- **基盤データ活用**: Phase 2 で取得したデータを基盤として活用
- **差分更新**: 基盤データ以降の差分データのみを取得
- **効率性**: API 制限を考慮した最適なデータ取得
- **データ品質**: 取得したデータの検証と品質保証

## 🏗️ システム構成図

```
CLI Commands (data_commands.py)
├── init → DatabaseCleanup
├── restore → BaseDataRestorer
├── update → DifferentialUpdater
├── calculate → TechnicalCalculator
└── setup → UnifiedSetup

Dependencies:
├── database_cleanup.py
├── base_data_restorer.py
├── differential_updater.py
├── technical_calculator.py
└── unified_setup.py

Base Data:
├── data/exchange_analytics_phase2_complete_2025-08-14.db
└── data/README_phase2_complete_2025-08-14.md

Existing Systems (活用):
├── scripts/cron/technical_indicators_calculator.py
├── src/infrastructure/analysis/technical_indicators.py
└── src/infrastructure/database/services/multi_timeframe_technical_indicator_service.py

External Services:
├── YahooFinanceClient
├── PriceDataRepositoryImpl
├── TechnicalIndicatorRepositoryImpl
└── DatabaseManager
```

## 📁 ファイル詳細仕様

### 新規作成ファイル

```
scripts/cron/
├── database_cleanup.py           # データベースクリーンアップ（既存）
├── base_data_restorer.py         # 基盤データ復元（新規）
├── differential_updater.py       # 差分データ更新（新規）
├── technical_calculator.py       # テクニカル指標計算（新規）
└── unified_setup.py             # 一括実行スクリプト（更新）
```

### 基盤データ

```
data/
├── exchange_analytics_phase2_complete_2025-08-14.db  # 基盤データバックアップ
└── README_phase2_complete_2025-08-14.md             # 基盤データ仕様書
```

### 既存システムの活用

```
既存ファイル（そのまま使用）
├── scripts/cron/technical_indicators_calculator.py  # テクニカル指標計算
├── src/infrastructure/analysis/technical_indicators.py  # TechnicalIndicatorsAnalyzer
└── src/infrastructure/database/services/multi_timeframe_technical_indicator_service.py  # マルチタイムフレーム対応
```

### 1. `scripts/cron/database_cleanup.py`（既存）

#### クラス設計

```python
class DatabaseCleanup:
    def __init__(self):
        self.database_url: str = "sqlite+aiosqlite:///data/exchange_analytics.db"
        self.db_path: str = "/app/data/exchange_analytics.db"
        self.session: Optional[AsyncSession] = None

    async def cleanup_database(self) -> bool:
        """データベースを完全にクリーンアップ"""

    async def create_tables(self) -> bool:
        """テーブル構造を作成"""

    async def verify_cleanup(self) -> bool:
        """クリーンアップの確認"""

    async def initialize_session(self) -> bool:
        """セッションの初期化"""

    async def cleanup(self) -> None:
        """リソースのクリーンアップ"""
```

### 2. `scripts/cron/base_data_restorer.py`（新規）

#### クラス設計

```python
class BaseDataRestorer:
    def __init__(self):
        self.base_backup_path: str = "/app/data/exchange_analytics_phase2_complete_2025-08-14.db"
        self.current_db_path: str = "/app/data/exchange_analytics.db"
        self.session: Optional[AsyncSession] = None

    async def restore_base_data(self) -> bool:
        """基盤データを復元"""

    async def _backup_current_database(self) -> None:
        """現在のデータベースをバックアップ"""

    async def _restore_from_backup(self) -> None:
        """バックアップから復元"""

    async def _verify_restoration(self) -> bool:
        """復元の確認"""

    async def _get_data_counts(self) -> Dict[str, int]:
        """各時間足のデータ件数を取得"""
```

#### メソッド詳細

**`restore_base_data()`**

```python
async def restore_base_data(self) -> bool:
    """
    基盤データを復元

    Returns:
        bool: 復元成功時True、失敗時False
    """
    try:
        print("🔄 基盤データの復元を開始...")

        # バックアップファイルの存在確認
        if not os.path.exists(self.base_backup_path):
            print(f"❌ 基盤データバックアップが見つかりません: {self.base_backup_path}")
            return False

        # 現在のデータベースをバックアップ
        await self._backup_current_database()

        # 基盤データを復元
        await self._restore_from_backup()

        # 復元の確認
        success = await self._verify_restoration()

        if success:
            print("✅ 基盤データの復元が完了しました")
        else:
            print("❌ 基盤データの復元に失敗しました")

        return success

    except Exception as e:
        print(f"❌ 基盤データ復元エラー: {e}")
        return False
```

**`_backup_current_database()`**

```python
async def _backup_current_database(self) -> None:
    """
    現在のデータベースをバックアップ
    """
    if os.path.exists(self.current_db_path):
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_path = f"{self.current_db_path}.backup_{timestamp}"
        shutil.copy2(self.current_db_path, backup_path)
        print(f"📦 現在のデータベースをバックアップ: {backup_path}")
```

**`_restore_from_backup()`**

```python
async def _restore_from_backup(self) -> None:
    """
    バックアップから復元
    """
    shutil.copy2(self.base_backup_path, self.current_db_path)
    print("📥 基盤データを復元しました")
```

**`_verify_restoration()`**

```python
async def _verify_restoration(self) -> bool:
    """
    復元の確認

    Returns:
        bool: 復元成功時True、失敗時False
    """
    try:
        conn = sqlite3.connect(self.current_db_path)
        cursor = conn.cursor()

        # データ件数の確認
        cursor.execute("SELECT COUNT(*) FROM price_data")
        count = cursor.fetchone()[0]

        print(f"📊 復元されたデータ件数: {count:,}件")

        # 各時間足の件数確認
        timeframe_counts = await self._get_data_counts()
        for timeframe, timeframe_count in timeframe_counts.items():
            print(f"   {timeframe}: {timeframe_count:,}件")

        conn.close()
        return True

    except Exception as e:
        print(f"❌ 復元確認エラー: {e}")
        return False
```

### 3. `scripts/cron/differential_updater.py`（新規）

#### クラス設計

```python
class DifferentialUpdater:
    def __init__(self, currency_pair: str = "USD/JPY"):
        self.currency_pair: str = currency_pair
        self.session: Optional[AsyncSession] = None
        self.price_repo: Optional[PriceDataRepositoryImpl] = None
        self.yahoo_client: YahooFinanceClient = YahooFinanceClient()

        # 基盤データの最終更新日時（Phase 2完了時）
        self.base_timestamps: Dict[str, datetime] = {
            "5m": datetime(2025, 8, 14, 9, 15, 0),
            "1h": datetime(2025, 8, 14, 9, 0, 0),
            "4h": datetime(2025, 8, 14, 8, 0, 0),
            "1d": datetime(2025, 8, 14, 8, 0, 0)
        }

    async def update_all_timeframes(self) -> Dict[str, int]:
        """全時間足の差分データを更新"""

    async def update_timeframe(self, timeframe: str) -> int:
        """特定時間足の差分データを更新"""

    async def _calculate_differential_period(self, timeframe: str) -> Tuple[Optional[str], Optional[str]]:
        """差分期間を計算"""

    async def _get_latest_timestamp(self, timeframe: str) -> Optional[datetime]:
        """データベース内の最新タイムスタンプを取得"""

    async def _fetch_differential_data(self, timeframe: str, start_date: str, end_date: str) -> int:
        """差分データを取得して保存"""

    async def _save_dataframe_to_db(self, df: pd.DataFrame, timeframe: str) -> int:
        """DataFrameをデータベースに保存"""

    async def initialize(self) -> bool:
        """初期化処理"""

    async def cleanup(self) -> None:
        """リソースのクリーンアップ"""
```

#### メソッド詳細

**`update_all_timeframes()`**

```python
async def update_all_timeframes(self) -> Dict[str, int]:
    """
    全時間足の差分データを更新

    Returns:
        Dict[str, int]: 各時間足の更新件数
    """
    results = {}

    for timeframe in ["5m", "1h", "4h", "1d"]:
        print(f"🔄 {timeframe}時間足の差分更新を開始...")
        count = await self.update_timeframe(timeframe)
        results[timeframe] = count
        print(f"✅ {timeframe}時間足更新完了: {count}件")

    return results
```

**`update_timeframe()`**

```python
async def update_timeframe(self, timeframe: str) -> int:
    """
    特定時間足の差分データを更新

    Args:
        timeframe: 時間足（"5m", "1h", "4h", "1d"）

    Returns:
        int: 更新件数
    """
    try:
        # 差分期間の計算
        start_date, end_date = await self._calculate_differential_period(timeframe)

        if not start_date or not end_date:
            print(f"ℹ️ {timeframe}の差分データはありません")
            return 0

        # 差分データの取得
        count = await self._fetch_differential_data(timeframe, start_date, end_date)

        return count

    except Exception as e:
        print(f"❌ {timeframe}差分更新エラー: {e}")
        return 0
```

**`_calculate_differential_period()`**

```python
async def _calculate_differential_period(self, timeframe: str) -> Tuple[Optional[str], Optional[str]]:
    """
    差分期間を計算

    Args:
        timeframe: 時間足

    Returns:
        Tuple[Optional[str], Optional[str]]: (開始日, 終了日) または (None, None)
    """
    # データベース内の最新タイムスタンプを取得
    latest_timestamp = await self._get_latest_timestamp(timeframe)

    if not latest_timestamp:
        print(f"⚠️ {timeframe}の既存データが見つかりません")
        return None, None

    # 現在時刻
    current_time = datetime.utcnow()

    # 差分期間の計算（重複を避けるため次のタイムスタンプから）
    if timeframe == "5m":
        start_date = latest_timestamp + timedelta(minutes=5)
    elif timeframe == "1h":
        start_date = latest_timestamp + timedelta(hours=1)
    elif timeframe == "4h":
        start_date = latest_timestamp + timedelta(hours=4)
    else:  # 1d
        start_date = latest_timestamp + timedelta(days=1)

    end_date = current_time

    # 差分が存在するかチェック
    if start_date >= end_date:
        print(f"ℹ️ {timeframe}の差分データはありません")
        return None, None

    return start_date.strftime("%Y-%m-%d"), end_date.strftime("%Y-%m-%d")
```

**`_get_latest_timestamp()`**

```python
async def _get_latest_timestamp(self, timeframe: str) -> Optional[datetime]:
    """
    データベース内の最新タイムスタンプを取得

    Args:
        timeframe: 時間足

    Returns:
        Optional[datetime]: 最新タイムスタンプ
    """
    try:
        # 特定時間足の最新タイムスタンプを取得
        query = select(PriceDataModel.timestamp).where(
            PriceDataModel.data_source.like(f"%{timeframe}%")
        ).order_by(PriceDataModel.timestamp.desc()).limit(1)

        result = await self.session.execute(query)
        latest = result.scalar_one_or_none()

        return latest

    except Exception as e:
        print(f"❌ 最新タイムスタンプ取得エラー: {e}")
        return None
```

### 4. `scripts/cron/technical_calculator.py`（新規）

#### クラス設計

```python
class TechnicalCalculator:
    def __init__(self, currency_pair: str = "USD/JPY"):
        self.currency_pair: str = currency_pair
        self.session: Optional[AsyncSession] = None

        # 既存システムの活用
        self.technical_analyzer: TechnicalIndicatorsAnalyzer = TechnicalIndicatorsAnalyzer()
        self.multi_timeframe_service: MultiTimeframeTechnicalIndicatorService = None

    async def calculate_all_indicators(self) -> Dict[str, int]:
        """全テクニカル指標を計算"""

    async def calculate_timeframe_indicators(self, timeframe: str) -> int:
        """特定時間足の指標を計算"""

    async def _initialize_existing_systems(self) -> bool:
        """既存システムの初期化"""

    async def initialize(self) -> bool:
        """初期化処理"""

    async def cleanup(self) -> None:
        """リソースのクリーンアップ"""
```

#### メソッド詳細

**`calculate_all_indicators()`**

```python
async def calculate_all_indicators(self) -> Dict[str, int]:
    """
    全テクニカル指標を計算

    Returns:
        Dict[str, int]: 各時間足の計算件数
    """
    results = {}

    for timeframe in ["5m", "1h", "4h", "1d"]:
        print(f"📊 {timeframe}時間足のテクニカル指標計算を開始...")
        count = await self.calculate_timeframe_indicators(timeframe)
        results[timeframe] = count
        print(f"✅ {timeframe}時間足指標計算完了: {count}件")

    return results
```

**`calculate_timeframe_indicators()`**

```python
async def calculate_timeframe_indicators(self, timeframe: str) -> int:
    """
    特定時間足の指標を計算

    Args:
        timeframe: 時間足

    Returns:
        int: 計算件数
    """
    try:
        # 既存のTechnicalIndicatorsCalculatorを使用
        calculator = TechnicalIndicatorsCalculator()
        await calculator.initialize()

        # 特定時間足の指標計算を実行
        count = await calculator.calculate_indicators_for_timeframe(
            self.currency_pair, timeframe
        )

        return count

    except Exception as e:
        print(f"❌ {timeframe}指標計算エラー: {e}")
        return 0
```

### 5. `scripts/cron/unified_setup.py`（更新）

#### クラス設計

```python
class UnifiedSetup:
    def __init__(self):
        self.database_cleanup: DatabaseCleanup = DatabaseCleanup()
        self.base_restorer: BaseDataRestorer = BaseDataRestorer()
        self.differential_updater: DifferentialUpdater = DifferentialUpdater()
        self.technical_calculator: TechnicalCalculator = TechnicalCalculator()

        self.step_results: Dict[str, Any] = {}
        self.error_log: List[str] = []

    async def run_full_setup(self) -> bool:
        """全処理を一括実行"""

    async def run_step_by_step(self) -> bool:
        """段階的に実行"""

    async def handle_errors(self, step: str, error: Exception) -> bool:
        """エラーハンドリング"""

    async def _execute_step(self, step_name: str, step_func: Callable) -> bool:
        """個別ステップの実行"""

    async def _generate_report(self) -> dict:
        """実行結果レポートの生成"""

    async def _rollback_on_error(self, step: str) -> bool:
        """エラー時のロールバック"""
```

#### メソッド詳細

**`run_full_setup()`**

```python
async def run_full_setup(self) -> bool:
    """
    全処理を一括実行

    Returns:
        bool: 成功時True、失敗時False
    """
    try:
        print("🚀 統合セットアップを開始します")
        print("=" * 60)

        # Step 1: データベース初期化
        print("📋 Step 1: データベース初期化")
        success = await self._execute_step("database_init", self.database_cleanup.cleanup_database)
        if not success:
            return False

        # Step 2: 基盤データの復元
        print("📋 Step 2: 基盤データの復元")
        success = await self._execute_step("base_restore", self.base_restorer.restore_base_data)
        if not success:
            return False

        # Step 3: 差分データの更新
        print("📋 Step 3: 差分データの更新")
        success = await self._execute_step("differential_update", self.differential_updater.update_all_timeframes)
        if not success:
            return False

        # Step 4: テクニカル指標計算
        print("📋 Step 4: テクニカル指標計算")
        success = await self._execute_step("technical_calculation", self.technical_calculator.calculate_all_indicators)
        if not success:
            return False

        # 結果レポートの生成
        await self._generate_report()

        print("🎉 統合セットアップが完了しました")
        return True

    except Exception as e:
        print(f"❌ 統合セットアップエラー: {e}")
        return False
```

## 🔄 処理フロー詳細

### 1. データベースクリーンアップ

```
1. 既存データベースファイルの削除
2. データベース接続の初期化
3. テーブル構造の作成
4. クリーンアップの確認
```

### 2. 基盤データ復元

```
1. 基盤データバックアップの存在確認
2. 現在のデータベースのバックアップ（存在する場合）
3. 基盤データの復元
4. 復元結果の確認
   - データ件数の確認
   - 各時間足の件数確認
   - データの整合性確認
```

### 3. 差分データ更新

```
1. 各時間足の最新タイムスタンプを取得
2. 差分期間の計算
   - 5分足: 最新タイムスタンプ + 5分 ～ 現在
   - 1時間足: 最新タイムスタンプ + 1時間 ～ 現在
   - 4時間足: 最新タイムスタンプ + 4時間 ～ 現在
   - 日足: 最新タイムスタンプ + 1日 ～ 現在
3. 差分データの取得
4. データの検証と保存
5. 重複チェックと更新
```

### 4. テクニカル指標計算

```
1. 既存テクニカル指標システムの初期化
2. 各時間足のデータ確認
3. 移動平均線の計算
   - SMA: 5, 10, 20, 50, 100, 200期間
   - EMA: 12, 26期間
4. ボリンジャーバンドの計算
5. RSI、MACD等の計算
6. 計算結果の保存
```

## 📊 データ構造

### 基盤データ仕様

**ファイル名**: `exchange_analytics_phase2_complete_2025-08-14.db`
**作成日時**: 2025 年 8 月 14 日 09:21
**ファイルサイズ**: 10.5 MB
**データ期間**: 2024 年 3 月 22 日 ～ 2025 年 8 月 14 日

**データ件数（合計: 22,320 件）**

- 5 分足: 16,690 件 (`yahoo_finance_5m`)
- 4 時間足: 2,179 件 (`yahoo_finance_4h`)
- 1 時間足: 1,394 件 (`yahoo_finance_1h`)
- 日足: 362 件 (`yahoo_finance_1d`)
- その他: 1,695 件（初期ロードデータ等）

### 差分データ仕様

**取得対象**: 基盤データの最新タイムスタンプ以降
**更新頻度**: 必要に応じて手動実行
**データ品質**: 基盤データと同等の品質基準

## 🛠️ 実装順序

### Phase 1: 基盤整備（完了）

1. データベースクリーンアップ実装
2. CLI コマンド基本構造更新

### Phase 2: データ処理（完了）

3. データ取得処理実装
4. 基盤データの確立

### Phase 3: 差分更新処理

5. 基盤データ復元実装
6. 差分データ更新実装

### Phase 4: 分析処理

7. テクニカル指標計算実装
8. 一括実行スクリプト実装

### Phase 5: 統合・テスト

9. 全処理の統合テスト
10. エラーハンドリングの強化
11. ドキュメントの更新

## 📈 品質保証

### テスト戦略

1. **単体テスト**: 各コンポーネントの個別テスト
2. **統合テスト**: 処理間の連携テスト
3. **エンドツーエンドテスト**: 全フローのテスト
4. **差分更新テスト**: 差分データの正確性テスト

### 監視項目

- データ取得成功率
- 差分更新の正確性
- 処理時間
- エラー発生率
- データ品質指標

## 🚨 エラーハンドリング

### エラー分類

1. **軽微なエラー**: 警告として処理を継続
2. **重要なエラー**: 処理を停止し、ユーザーに選択を求める
3. **致命的なエラー**: 処理を完全に停止

### 復旧オプション

- **再試行**: 同じ処理を再実行
- **スキップ**: 問題のある処理をスキップ
- **ロールバック**: 前の状態に戻す
- **基盤データ復元**: 基盤データから再開始

## 📝 コーディングルール

### コード品質基準

#### 1. 行長制限

- **最大行長**: 88 文字（Black フォーマッタのデフォルト）
- **推奨行長**: 80 文字以下
- **例外**: 長い URL、ファイルパス、コメントは可

#### 2. インポート文の整理

- 標準ライブラリ → サードパーティ → ローカルモジュールの順
- 各グループ間に空行を挿入
- 未使用インポートの削除

#### 3. 文字列フォーマット

- f-string の使用を推奨
- 長い文字列は複数行に分割
- 文字列連結は`+`ではなく`join()`を使用

#### 4. 関数・メソッド定義

- 引数が多い場合は複数行に分割
- 型ヒントの使用
- デフォルト引数の適切な配置

#### 5. 条件文・ループ

- 長い条件は複数行に分割
- ネストは 3 レベル以下
- 早期リターンの使用

### 実装時のチェックリスト

#### コード作成時

- [ ] 行長が 88 文字以下であることを確認
- [ ] インポート文が整理されている
- [ ] 未使用の変数・インポートがない
- [ ] 適切な型ヒントが付いている
- [ ] エラーハンドリングが適切

#### コードレビュー時

- [ ] 行長制限の遵守
- [ ] コードの可読性
- [ ] 命名規則の統一
- [ ] ドキュメンテーションの充実
- [ ] テストカバレッジの確認

### 自動化ツール

#### 1. フォーマッタ

- **Black**: コードフォーマットの自動化
- **isort**: インポート文の自動整理
- **autopep8**: PEP8 準拠の自動修正

#### 2. リント

- **flake8**: コード品質チェック
- **pylint**: 包括的なコード分析
- **mypy**: 型チェック

#### 3. 設定ファイル

```toml
# pyproject.toml
[tool.black]
line-length = 88
target-version = ['py39']

[tool.isort]
profile = "black"
line_length = 88

[tool.flake8]
max-line-length = 88
extend-ignore = ["E203", "W503"]
```

### 実装前の準備

#### 1. 開発環境の設定

- [ ] Black フォーマッタのインストール
- [ ] isort のインストール
- [ ] flake8 のインストール
- [ ] エディタの設定（自動フォーマット）

#### 2. プレコミットフック

- [ ] コードフォーマットの自動実行
- [ ] リントチェックの自動実行
- [ ] 型チェックの自動実行

#### 3. CI/CD パイプライン

- [ ] 自動フォーマットチェック
- [ ] リントエラーの検出
- [ ] テストの自動実行

---

**作成日**: 2025 年 1 月
**バージョン**: 2.0
**作成者**: AI Assistant
**承認者**: ユーザー
**更新日**: 2025 年 8 月 14 日
**更新内容**: 新しいワークフロー（基盤データ復元 → 差分更新）への対応

## 🎯 実装状況 (SoC - State of Code)

### 2.1 基盤システム ✅ 完了

- [x] **CLI コマンド基盤**: `typer`を使用したコマンドラインインターフェース
- [x] **データベース接続**: SQLAlchemy AsyncSession による非同期接続
- [x] **環境変数管理**: `DATABASE_URL`、`PYTHONPATH`の適切な設定
- [x] **エラーハンドリング**: 包括的な例外処理とユーザーフレンドリーなエラーメッセージ

### 2.2 データ管理機能 ✅ 完了

- [x] **基盤データ復元**: `base_data_restorer.py` - Phase 2 バックアップからの復元
- [x] **差分データ更新**: `differential_updater.py` - 最新タイムスタンプ以降の差分取得
- [x] **統合テクニカル指標計算**: `unified_technical_calculator.py` - TA-Lib 使用
- [x] **テクニカル指標可視化**: `technical_visualizer.py` - 高視認性での指標表示

### 2.3 高度な分析機能 ✅ 完了

- [x] **ダイバージェンス検出**: `divergence_detector.py` - 価格と指標の乖離分析
  - 強気/弱気ダイバージェンスの自動検出
  - RSI、MACD、ストキャスティクス対応
  - 信頼度計算機能
- [x] **サポート・レジスタンス分析**: `support_resistance_analyzer.py` - 重要レベルの自動検出
  - 移動平均線ベースのレベル検出
  - ピボットポイント計算
  - 強度評価機能
- [x] **モメンタム分析**: `momentum_analyzer.py` - 指標の変化速度分析
  - 変化率と速度の計算
  - 総合モメンタム評価
  - 複数指標の統合分析

### 2.4 統合分析システム ✅ 完了

- [x] **包括的分析機能**: `comprehensive_analysis` - 3 つの分析を統合実行
  - ダイバージェンス、サポート・レジスタンス、モメンタムの統合
  - 市場状況の総合判断
  - 推奨アクションの自動生成
- [x] **高度なシグナル分析**: `advanced_signal_analyzer.py` - 包括的シグナル分析
  - シグナル強度と信頼度の評価
  - トレンド分析とボラティリティ分析
  - 複数時間足での分析

### 2.5 CLI コマンド統合 ✅ 完了

- [x] **データ管理コマンド**:
  - `data restore-base`: 基盤データ復元
  - `data update`: 差分データ更新
  - `data calculate-unified`: 統合テクニカル指標計算
- [x] **分析コマンド**:
  - `data detect-divergences`: ダイバージェンス検出
  - `data analyze-support-resistance`: サポート・レジスタンス分析
  - `data analyze-momentum`: モメンタム分析
  - `data comprehensive-analysis`: 包括的分析（新規追加）
  - `data analyze-signals`: 高度なシグナル分析
  - `data visualize`: テクニカル指標可視化

### 2.6 視認性と UX ✅ 完了

- [x] **Rich ライブラリ活用**: 色分け、アイコン、テーブル表示
- [x] **構造化された出力**: セクション区切りと階層的表示
- [x] **総合判断システム**: 市場状況の自動判定と推奨アクション
- [x] **柔軟なオプション**: 分析の選択実行とパラメータ調整

## 3. 新しい分析機能の詳細

### 3.1 ダイバージェンス検出システム

#### 機能概要

価格とテクニカル指標の乖離を分析し、ダイバージェンスを検出する機能

#### 実装ファイル

- `scripts/cron/divergence_detector.py`

#### 主要機能

- **強気ダイバージェンス**: 価格下落中に指標が上昇
- **弱気ダイバージェンス**: 価格上昇中に指標が下落
- **対応指標**: RSI、MACD、ストキャスティクス
- **信頼度計算**: 価格変動と指標変動から自動計算

#### 使用例

```bash
exchange-analytics data detect-divergences --timeframe M5 --days 7
```

### 3.2 サポート・レジスタンス分析システム

#### 機能概要

移動平均線を活用した重要レベルの自動検出機能

#### 実装ファイル

- `scripts/cron/support_resistance_analyzer.py`

#### 主要機能

- **移動平均線ベース**: SMA、EMA を使用したレベル検出
- **ピボットポイント**: 標準的なピボットポイント計算
- **強度評価**: 移動平均線の傾きと価格との相関から計算
- **現在価格との関係**: 最寄りレベルとの距離を表示

#### 使用例

```bash
exchange-analytics data analyze-support-resistance --timeframe H1 --days 7
```

### 3.3 モメンタム分析システム

#### 機能概要

指標の変化速度を分析する機能

#### 実装ファイル

- `scripts/cron/momentum_analyzer.py`

#### 主要機能

- **変化率計算**: 指標の変化率をパーセンテージで表示
- **速度分析**: 指標の変化速度を数値で評価
- **総合評価**: 複数指標の統合的なモメンタム評価
- **対応指標**: RSI、MACD、ストキャスティクス、移動平均線

#### 使用例

```bash
exchange-analytics data analyze-momentum --timeframe M5 --days 3
```

### 3.4 統合分析システム

#### 機能概要

3 つの分析機能を統合実行し、市場状況の総合判断を提供

#### 実装ファイル

- `src/presentation/cli/commands/data_commands.py` (comprehensive_analysis)

#### 主要機能

- **統合実行**: ダイバージェンス、サポート・レジスタンス、モメンタムを一括実行
- **総合判断**: 各分析の結果を統合して市場状況を判定
- **推奨アクション**: 具体的な取引戦略を自動生成
- **柔軟なオプション**: 特定の分析のみ実行可能

#### 使用例

```bash
# 全分析実行
exchange-analytics data comprehensive-analysis

# 特定分析のみ
exchange-analytics data comprehensive-analysis --no-momentum

# 時間足と期間指定
exchange-analytics data comprehensive-analysis --timeframe H1 --days 3
```

## 4. 出力例

### 4.1 包括的分析の出力例

```
🎯 包括的分析機能
📊 分析対象: USD/JPY (M5時間足, 7日間)

================================================================================
🔍 ダイバージェンス分析実行中...
✅ ダイバージェンス分析完了

================================================================================
📈 サポート・レジスタンス分析実行中...
✅ サポート・レジスタンス分析完了

================================================================================
⚡ モメンタム分析実行中...
✅ モメンタム分析完了

================================================================================
📋 分析結果サマリー
================================================================================

🎯 ダイバージェンス検出結果
--------------------------------------------------
🟢 強気ダイバージェンス (2件):
  1. MACD - 信頼度: 0.50
  2. STOCH - 信頼度: 0.50

🔴 弱気ダイバージェンス (1件):
  1. STOCH - 信頼度: 0.50

📊 サポート・レジスタンス分析結果
--------------------------------------------------
🔴 レジスタンスレベル:
  1. 149.349 (強度: 0.80) - R2レジスタンスレベル
  2. 147.871 (強度: 0.70) - R1レジスタンスレベル

🟢 サポートレベル:
  1. 144.731 (強度: 0.80) - S2サポートレベル
  2. 145.562 (強度: 0.70) - S1サポートレベル

⚡ モメンタム分析結果
--------------------------------------------------
📊 RSIモメンタム: 🔴 強い下降 (-10.49%)
📊 MACDモメンタム: 🔴 下降 (-1.16%)
📊 STOCHモメンタム: 🟢 上昇 (+4.63%)

================================================================================
🎯 総合分析評価
================================================================================
  🔍 ダイバージェンス: 3件検出
  📊 サポート・レジスタンス: 4件検出
  ⚡ モメンタム: 下降傾向

--------------------------------------------------------------------------------
📈 市場状況の総合判断
--------------------------------------------------------------------------------
📊 分析結果:
  🟢 ダイバージェンス: 強気
  🔴 モメンタム: 下降

🎯 総合判断:
  ⚪ 中立市場 - 様子見推奨

💡 推奨アクション:
  • 明確なシグナルを待つ
  • レンジ相場での取引を検討
  • リスク管理を強化
```

## 5. 今後の展開

### 5.1 短期計画（1-3 ヶ月）

- [ ] **Discord 配信機能**: リアルタイムシグナル通知
- [ ] **アラートシステム**: 条件付き通知機能
- [ ] **バックテスト機能**: 戦略の検証システム
- [ ] **ポートフォリオ管理**: 複数通貨ペアの統合管理

### 5.2 中期計画（3-6 ヶ月）

- [ ] **リスク管理**: ポジションサイズとストップロス管理
- [ ] **ダイバージェンス検出強化**: 隠れダイバージェンス対応
- [ ] **サポート・レジスタンス強化**: 自動検出精度向上
- [ ] **ボラティリティ予測**: 将来のボラティリティ予測

### 5.3 長期計画（6 ヶ月以上）

- [ ] **自動売買システム**: 完全自動化トレーディング
- [ ] **ソーシャルトレーディング**: コミュニティ機能
- [ ] **Web UI**: ブラウザベースのインターフェース
- [ ] **機械学習統合**: AI による予測精度向上

## 6. パフォーマンス指標

### 6.1 実行時間

- **基盤データ復元**: ~5 秒
- **差分データ更新**: ~30 秒（データ量による）
- **テクニカル指標計算**: ~10 秒
- **包括的分析**: ~15 秒

### 6.2 精度指標

- **ダイバージェンス検出精度**: 信頼度 0.5-0.9
- **サポート・レジスタンス精度**: 強度 0.3-0.9
- **モメンタム分析精度**: 変化率 ±5%以上で検出

---

**最終更新**: 2025 年 1 月 27 日
**実装状況**: Phase 3 完了（高度な分析機能統合完了）
**次のフェーズ**: Phase 4（自動化と通知機能）
