# CLI データベース初期化システム実装仕様書

## 📋 概要

### 目的

- 設計書に基づく具体的な実装仕様の定義
- 各ファイルの依存関係とクラス設計の詳細化
- 処理フローとメソッドの具体的な機能定義

### 基本方針

- **個別データ取得**: 5 分足、1 時間足、4 時間足、日足を個別に取得
- **API 制限対応**: Yahoo Finance API の制限内で最適なデータを取得
- **データ品質**: 取得したデータの検証と品質保証

## 🏗️ システム構成図

```
CLI Commands (data_commands.py)
├── init → DatabaseCleanup
├── load → DataLoader
├── complete → DataCompletionProcessor
├── calculate → TechnicalCalculator
└── setup → UnifiedSetup

Dependencies:
├── database_cleanup.py
├── data_loader.py
├── data_completion.py
└── unified_setup.py

Existing Systems (活用):
├── scripts/cron/technical_indicators_calculator.py
├── src/infrastructure/analysis/technical_indicators.py
└── src/infrastructure/database/services/multi_timeframe_technical_indicator_service.py

External Services:
├── YahooFinanceClient
├── PriceDataRepositoryImpl
├── TechnicalIndicatorRepositoryImpl
└── DatabaseManager
```

## 📁 ファイル詳細仕様

### 新規作成ファイル

```
scripts/cron/
├── database_cleanup.py           # データベースクリーンアップ
├── data_loader.py               # データ取得処理
├── data_completion.py           # データ補完処理（hybrid_initialization.pyから改名）
└── unified_setup.py            # 一括実行スクリプト
```

### 既存システムの活用

```
既存ファイル（そのまま使用）
├── scripts/cron/technical_indicators_calculator.py  # テクニカル指標計算
├── src/infrastructure/analysis/technical_indicators.py  # TechnicalIndicatorsAnalyzer
└── src/infrastructure/database/services/multi_timeframe_technical_indicator_service.py  # マルチタイムフレーム対応
```

### 1. `scripts/cron/database_cleanup.py`

#### クラス設計

```python
class DatabaseCleanup:
    def __init__(self):
        self.database_url: str = "sqlite+aiosqlite:///data/exchange_analytics.db"
        self.db_path: str = "/app/data/exchange_analytics.db"
        self.session: Optional[AsyncSession] = None

    async def cleanup_database(self) -> bool:
        """データベースを完全にクリーンアップ"""

    async def create_tables(self) -> bool:
        """テーブル構造を作成"""

    async def verify_cleanup(self) -> bool:
        """クリーンアップの確認"""

    async def initialize_session(self) -> bool:
        """セッションの初期化"""

    async def cleanup(self) -> None:
        """リソースのクリーンアップ"""
```

#### メソッド詳細

**`cleanup_database()`**

```python
async def cleanup_database(self) -> bool:
    """
    データベースを完全にクリーンアップ

    Returns:
        bool: 成功/失敗
    """
    # 1. 既存データベースファイルの削除
    # 2. データベース接続の初期化
    # 3. テーブル構造の作成
    # 4. クリーンアップの確認
```

**`create_tables()`**

```python
async def create_tables(self) -> bool:
    """
    テーブル構造を作成

    Returns:
        bool: 成功/失敗
    """
    # 1. Base.metadata.create_all()の実行
    # 2. 各テーブルの存在確認
    # 3. インデックスの作成
```

#### 処理フロー

```
1. 既存データベースファイルの削除
2. データベース接続の初期化
3. テーブル構造の作成
4. インデックスの作成
5. クリーンアップの確認
6. セッションの初期化
```

### 2. `scripts/cron/data_loader.py`

#### クラス設計

```python
class DataLoader:
    def __init__(self):
        self.currency_pair: str = "USD/JPY"
        self.session: Optional[AsyncSession] = None
        self.yahoo_client: YahooFinanceClient = YahooFinanceClient()
        self.price_repo: Optional[PriceDataRepositoryImpl] = None

        # 個別取得設定（Yahoo Finance API制限に基づく）
        self.timeframe_configs = {
            "5m": {
                "period": "7d",       # 7日分（API制限）
                "interval": "5m",
                "description": "5分足",
                "max_records": 10000
            },
            "1h": {
                "period": "30d",      # 30日分（API制限）
                "interval": "1h",
                "description": "1時間足",
                "max_records": 10000
            },
            "4h": {
                "period": "60d",      # 60日分（API制限）
                "interval": "4h",
                "description": "4時間足",
                "max_records": 10000
            },
            "1d": {
                "period": "365d",     # 365日分（API制限）
                "interval": "1d",
                "description": "日足",
                "max_records": 10000
            }
        }

    async def load_multi_timeframe_data(self) -> int:
        """全時間足のデータを個別に取得"""

    async def load_timeframe_data(self, timeframe: str) -> int:
        """特定時間足のデータを取得"""

    async def verify_data_quality(self, timeframe: str) -> bool:
        """データ品質の確認"""

    async def _fetch_and_save_timeframe(self, timeframe: str, config: dict) -> int:
        """特定時間足のデータを取得して保存"""

    async def _validate_timeframe_data(self, data: pd.DataFrame, timeframe: str) -> bool:
        """時間足データの検証"""

    async def initialize(self) -> bool:
        """初期化"""

    async def cleanup(self) -> None:
        """リソースのクリーンアップ"""
```

#### メソッド詳細

**`load_multi_timeframe_data()`**

```python
async def load_multi_timeframe_data(self) -> int:
    """
    全時間足のデータを個別に取得

    Returns:
        int: 取得したデータ総数
    """
    # 1. 各時間足を個別に取得
    # 2. データ品質の検証
    # 3. データベースへの保存
    # 4. 取得結果の集計
```

**`load_timeframe_data()`**

```python
async def load_timeframe_data(self, timeframe: str) -> int:
    """
    特定時間足のデータを取得

    Args:
        timeframe: 時間足（5m, 1h, 4h, 1d）

    Returns:
        int: 取得したデータ数
    """
    # 1. 時間足設定の取得
    # 2. Yahoo Finance APIからのデータ取得
    # 3. データの検証
    # 4. データベースへの保存
```

**`_fetch_and_save_timeframe()`**

```python
async def _fetch_and_save_timeframe(self, timeframe: str, config: dict) -> int:
    """
    特定時間足のデータを取得して保存

    Args:
        timeframe: 時間足
        config: 設定情報

    Returns:
        int: 保存したデータ数
    """
    # 1. Yahoo Finance APIからのデータ取得
    # 2. データの前処理
    # 3. データの検証
    # 4. データベースへの保存
    # 5. 重複チェックと更新
```

#### 処理フロー

```
1. セッションの初期化
2. 各時間足の個別取得
   - 5分足: 7日分
   - 1時間足: 30日分
   - 4時間足: 60日分
   - 日足: 365日分
3. データ品質の検証
4. データベースへの保存
5. 取得結果の集計
```

### 3. `scripts/cron/data_completion.py`

#### クラス設計

```python
class DataCompletionProcessor:
    def __init__(self):
        self.currency_pair: str = "USD/JPY"
        self.session: Optional[AsyncSession] = None
        self.price_repo: Optional[PriceDataRepositoryImpl] = None

    async def complete_1h_data(self) -> int:
        """1時間足データを補完"""

    async def complete_4h_data(self) -> int:
        """4時間足データを補完"""

    async def complete_all_data(self) -> dict:
        """全データを補完"""

    async def verify_completion(self) -> dict:
        """補完結果の確認"""

    async def _aggregate_1h_from_5m(self) -> int:
        """5分足から1時間足を集計"""

    async def _aggregate_4h_from_5m(self) -> int:
        """5分足から4時間足を集計"""

    async def _create_1h_data(self, hour_data: list, timestamp: datetime) -> Optional[PriceDataModel]:
        """1時間足データを作成"""

    async def _create_4h_data(self, four_hour_data: list, timestamp: datetime) -> Optional[PriceDataModel]:
        """4時間足データを作成"""

    async def _check_data_status(self) -> dict:
        """データ状況を確認"""

    async def initialize(self) -> bool:
        """初期化"""

    async def cleanup(self) -> None:
        """リソースのクリーンアップ"""
```

#### メソッド詳細

**`complete_1h_data()`**

```python
async def complete_1h_data(self) -> int:
    """
    1時間足データを補完

    Returns:
        int: 補完したデータ数
    """
    # 1. 5分足データの状況確認
    # 2. 1時間足データの欠損部分特定
    # 3. 5分足から1時間足への集計
    # 4. 補完データの保存
```

**`_aggregate_1h_from_5m()`**

```python
async def _aggregate_1h_from_5m(self) -> int:
    """
    5分足から1時間足を集計

    Returns:
        int: 集計したデータ数
    """
    # 1. 最新の5分足データを取得
    # 2. 7日分の5分足データを使用
    # 3. 1時間単位でグループ化
    # 4. OHLCVの計算
    # 5. 1時間足データの作成と保存
```

**`_create_1h_data()`**

```python
async def _create_1h_data(self, hour_data: list, timestamp: datetime) -> Optional[PriceDataModel]:
    """
    1時間足データを作成

    Args:
        hour_data: 1時間分の5分足データ
        timestamp: 1時間足のタイムスタンプ

    Returns:
        Optional[PriceDataModel]: 作成した1時間足データ
    """
    # 1. データ件数の確認（最低12件必要）
    # 2. OHLCVの計算
    # 3. PriceDataModelの作成
    # 4. データソースの設定
```

#### 処理フロー

```
1. データ状況の確認
2. 1時間足データの補完
   - 7日分の5分足データを使用
   - 12件の5分足から1時間足を作成
3. 4時間足データの補完
   - 30日分の5分足データを使用
   - 48件の5分足から4時間足を作成
4. 補完結果の確認
```

### 4. テクニカル指標計算（既存システム活用）

#### 既存システムの活用

**使用する既存ファイル**:

- `scripts/cron/technical_indicators_calculator.py` - メインのテクニカル指標計算スクリプト
- `src/infrastructure/analysis/technical_indicators.py` - TechnicalIndicatorsAnalyzer
- `src/infrastructure/database/services/multi_timeframe_technical_indicator_service.py` - マルチタイムフレーム対応サービス

#### クラス設計（既存システムの拡張）

```python
class TechnicalCalculator:
    def __init__(self):
        self.currency_pair: str = "USD/JPY"
        self.session: Optional[AsyncSession] = None

        # 既存システムの活用
        self.technical_analyzer: TechnicalIndicatorsAnalyzer = TechnicalIndicatorsAnalyzer()
        self.multi_timeframe_service: MultiTimeframeTechnicalIndicatorService = None
        self.indicator_calculator: TechnicalIndicatorsCalculator = None

    async def calculate_all_indicators(self) -> int:
        """全テクニカル指標を計算（既存システムを使用）"""

    async def calculate_timeframe_indicators(self, timeframe: str) -> int:
        """特定時間足の指標を計算"""

    async def initialize(self) -> bool:
        """初期化（既存システムの初期化）"""

    async def cleanup(self) -> None:
        """リソースのクリーンアップ"""
```

#### メソッド詳細

**`calculate_all_indicators()`**

```python
async def calculate_all_indicators(self) -> int:
    """
    全テクニカル指標を計算（既存システムを使用）

    Returns:
        int: 計算した指標総数
    """
    # 1. 既存のTechnicalIndicatorsCalculatorを初期化
    # 2. calculate_all_indicators()メソッドを実行
    # 3. 結果の集計とレポート生成
```

**`calculate_timeframe_indicators()`**

```python
async def calculate_timeframe_indicators(self, timeframe: str) -> int:
    """
    特定時間足の指標を計算

    Args:
        timeframe: 時間足（5m, 1h, 4h, 1d）

    Returns:
        int: 計算した指標数
    """
    # 1. 既存のMultiTimeframeTechnicalIndicatorServiceを使用
    # 2. 特定時間足の指標計算を実行
    # 3. 結果の保存
```

#### 処理フロー

```
1. 既存システムの初期化
   - TechnicalIndicatorsAnalyzer
   - MultiTimeframeTechnicalIndicatorService
   - TechnicalIndicatorsCalculator
2. 各時間足のデータ確認
3. 既存システムによる指標計算
   - RSI (期間14, レベル70/50/30)
   - MACD (12,26,9)
   - ボリンジャーバンド (20,2)
   - 移動平均線 (SMA/EMA)
4. 計算結果のデータベース保存
5. 結果レポートの生成
```

### 5. `scripts/cron/unified_setup.py`

#### クラス設計

```python
class UnifiedSetup:
    def __init__(self):
        self.database_cleanup: DatabaseCleanup = DatabaseCleanup()
        self.data_loader: DataLoader = DataLoader()
        self.data_completion: DataCompletionProcessor = DataCompletionProcessor()
        self.technical_calculator: TechnicalCalculator = TechnicalCalculator()

        self.step_results: dict = {}
        self.error_log: list = []

    async def run_full_setup(self) -> bool:
        """全処理を一括実行"""

    async def run_step_by_step(self) -> bool:
        """段階的に実行"""

    async def handle_errors(self, step: str, error: Exception) -> bool:
        """エラーハンドリング"""

    async def _execute_step(self, step_name: str, step_func: callable) -> bool:
        """個別ステップの実行"""

    async def _generate_report(self) -> dict:
        """実行結果レポートの生成"""

    async def _rollback_on_error(self, failed_step: str) -> bool:
        """エラー時のロールバック"""
```

#### メソッド詳細

**`run_full_setup()`**

```python
async def run_full_setup(self) -> bool:
    """
    全処理を一括実行

    Returns:
        bool: 成功/失敗
    """
    # 1. データベースクリーンアップ
    # 2. データ取得
    # 3. データ補完
    # 4. テクニカル指標計算
    # 5. 結果レポートの生成
```

**`run_step_by_step()`**

```python
async def run_step_by_step(self) -> bool:
    """
    段階的に実行

    Returns:
        bool: 成功/失敗
    """
    # 1. 各ステップの実行確認
    # 2. ステップごとの実行
    # 3. エラーハンドリング
    # 4. 結果の確認
```

#### 処理フロー

```
1. データベースクリーンアップ
2. データ取得（各時間足を個別に取得）
3. データ補完（5分足から1時間足・4時間足を補完）
4. テクニカル指標計算
5. 結果レポートの生成
```

## 🔄 依存関係図

```
CLI Commands
    ↓
DatabaseCleanup ← DatabaseManager
    ↓
DataLoader ← YahooFinanceClient, PriceDataRepositoryImpl
    ↓
DataCompletionProcessor ← PriceDataRepositoryImpl
    ↓
TechnicalCalculator ← TechnicalIndicatorsAnalyzer, TechnicalIndicatorRepositoryImpl
    ↓
UnifiedSetup ← All Components
```

## 📊 データフロー

### 1. データ取得フロー

```
Yahoo Finance API
    ↓
個別時間足取得
    ├── 5分足: 7日分
    ├── 1時間足: 30日分
    ├── 4時間足: 60日分
    └── 日足: 365日分
    ↓
データ検証
    ↓
データベース保存
```

### 2. データ補完フロー

```
5分足データ
    ↓
1時間足補完（7日分の5分足を使用）
    ↓
4時間足補完（30日分の5分足を使用）
    ↓
補完データの保存
```

### 3. テクニカル指標計算フロー

```
各時間足データ
    ↓
移動平均線計算
    ↓
ボリンジャーバンド計算
    ↓
RSI、MACD計算
    ↓
指標データの保存
```

## 🛠️ 実装順序

### Phase 1: 基盤整備

1. `database_cleanup.py`の実装
2. CLI コマンドの基本構造更新

### Phase 2: データ処理

3. `data_loader.py`の実装（個別取得対応）
4. `data_completion.py`の実装

### Phase 3: 分析処理

5. 既存テクニカル指標システムの統合
6. `unified_setup.py`の実装

### Phase 4: 統合・テスト

7. 全処理の統合テスト
8. エラーハンドリングの強化

## 📈 期待される効果

### データ取得の改善

- **個別取得**: 各時間足を個別に取得することで、API 制限内で最大のデータを取得
- **データ品質**: 取得したデータの検証と品質保証
- **エラーハンドリング**: 各時間足での取得失敗時の適切な処理

### システムの改善

- **責任の明確化**: 各コンポーネントが単一の責任を持つ
- **保守性の向上**: 段階的な実行とデバッグが容易
- **拡張性の確保**: 新機能の追加が容易
- **エラーハンドリングの強化**: 詳細なエラー情報と復旧オプション

---

**作成日**: 2025 年 1 月
**バージョン**: 1.0
**作成者**: AI Assistant
**承認者**: ユーザー
